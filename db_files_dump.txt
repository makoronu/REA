================================================================================
REA DBé–¢é€£ãƒ•ã‚¡ã‚¤ãƒ«å†…å®¹ãƒ€ãƒ³ãƒ—
================================================================================

================================================================================
ğŸ“„ ãƒ•ã‚¡ã‚¤ãƒ«: .env
================================================================================
DATABASE_URL=***MASKED***
DB_HOST=localhost
DB_PORT=5432
DB_NAME=real_estate_db
DB_USER=rea_user
DB_PASSWORD=***MASKED***

================================================================================
ğŸ“„ ãƒ•ã‚¡ã‚¤ãƒ«: docker-compose.yml
================================================================================
version: '3.8'

services:
  postgres:
    image: postgres:15
    container_name: rea-postgres
    environment:
      POSTGRES_DB: real_estate_db
      POSTGRES_USER: rea_user
      POSTGRES_PASSWORD: ***MASKED***
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
    restart: unless-stopped

  redis:
    image: redis:7
    container_name: rea-redis
    ports:
      - "6379:6379"
    restart: unless-stopped

  rea-api:
    build: ./rea-api
    container_name: rea-api
    ports:
      - "8000:8000"
    depends_on:
      - postgres
      - redis
    environment:
      - DATABASE_URL=***MASKED***
      - REDIS_URL=redis://redis:6379
    volumes:
      - ./rea-api:/app
      - ./rea-api/uploads:/app/uploads
    restart: unless-stopped

  rea-scraper:
    build: ./rea-scraper
    container_name: rea-scraper
    depends_on:
      - postgres
      - redis
    environment:
      - DATABASE_URL=***MASKED***
      - DISPLAY=:99
    volumes:
      - ./rea-scraper:/app
      - ./rea-scraper/downloads:/app/downloads
    restart: unless-stopped

  rea-publisher:
    build: ./rea-publisher
    container_name: rea-publisher
    depends_on:
      - postgres
      - rea-api
    environment:
      - DATABASE_URL=***MASKED***
      - API_URL=http://rea-api:8000
    volumes:
      - ./rea-publisher:/app
    restart: unless-stopped

volumes:
  postgres_data:
    driver: local


================================================================================
ğŸ“„ ãƒ•ã‚¡ã‚¤ãƒ«: scripts/spec_generator/config.py
================================================================================
"""
REAä»•æ§˜æ›¸ç”Ÿæˆãƒ„ãƒ¼ãƒ« è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«
"""
from pathlib import Path

class Config:
    # ãƒ‘ã‚¹è¨­å®š
    PROJECT_ROOT = Path(__file__).parent.parent.parent
    OUTPUT_DIR = PROJECT_ROOT / 'docs' / 'claude_specs'
    
    # ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹è¨­å®š
    DB_NAME = "real_estate_db"
    DB_USER = "postgres"
    DB_HOST = "localhost"
    DB_PORT = "5432"
    
    # APIè¨­å®š
    API_URL = "http://localhost:8005"
    API_TIMEOUT = 2
    
    # ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆæƒ…å ±
    PROJECT_NAME = "REA (Real Estate Automation)"
    DESCRIPTION = "ä¸å‹•ç”£æ¥­å‹™å®Œå…¨è‡ªå‹•åŒ–ã‚·ã‚¹ãƒ†ãƒ  Pythonç‰ˆ"
    GITHUB = "https://github.com/makoronu/REA"
    CURRENT_PHASE = "Phase 2/5 å®Œäº†ï¼ˆã‚¹ã‚¯ãƒ¬ã‚¤ãƒ”ãƒ³ã‚°å®Ÿè£…æ¸ˆã¿ï¼‰"
    
    # å®Ÿè£…çŠ¶æ³
    COMPLETED_PHASES = [
        {
            'phase': 'Phase 1',
            'name': 'ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹åŸºç›¤ãƒ»API',
            'details': [
                'PostgreSQL 15 + 11ãƒ†ãƒ¼ãƒ–ãƒ«',
                'FastAPI + 8ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆ', 
                'å…ƒè«‹ä¼šç¤¾æƒ…å ±ç®¡ç†æ©Ÿèƒ½'
            ]
        },
        {
            'phase': 'Phase 2',
            'name': 'ã‚¹ã‚¯ãƒ¬ã‚¤ãƒ”ãƒ³ã‚°ï¼ˆMacç‰ˆï¼‰',
            'details': [
                'ãƒ›ãƒ¼ãƒ ã‚ºå¯¾å¿œå®Œäº†',
                'æ®µéšå‡¦ç†ã‚·ã‚¹ãƒ†ãƒ å®Ÿè£…',
                'Botå¯¾ç­–å®Ÿè£…æ¸ˆã¿'
            ]
        }
    ]
    
    IN_PROGRESS = {
        'phase': 'Phase 3',
        'name': 'Reactç®¡ç†ç”»é¢ãƒ»è‡ªå‹•å…¥ç¨¿',
        'progress': 'è¨­è¨ˆæ®µéš'
    }
    
    PLANNED = [
        'Phase 4: AIæ©Ÿèƒ½ãƒ»æ¤œç´¢æœ€é©åŒ–',
        'Phase 5: å…¬é–‹æ¤œç´¢ã‚µã‚¤ãƒˆ'
    ]
    
    # æŠ€è¡“ã‚¹ã‚¿ãƒƒã‚¯
    TECH_STACK = {
        'backend': [
            'Python 3.9+',
            'FastAPI 0.104.1',
            'SQLAlchemy 2.0.23',
            'PostgreSQL 15',
            'Docker'
        ],
        'scraping': [
            'Selenium 4.15.2',
            'undetected-chromedriver 3.5.3',
            'BeautifulSoup4 4.12.2'
        ],
        'planned': [
            'React 18',
            'TypeScript',
            'Tailwind CSS'
        ]
    }

================================================================================
ğŸ“„ ãƒ•ã‚¡ã‚¤ãƒ«: scripts/spec_generator/generate_claude_context.py
================================================================================
#!/usr/bin/env python3
"""
REAä»•æ§˜æ›¸è‡ªå‹•ç”Ÿæˆãƒ„ãƒ¼ãƒ« ãƒ¡ã‚¤ãƒ³ã‚¹ã‚¯ãƒªãƒ—ãƒˆ
ã‚·ãƒ³ãƒ—ãƒ«ã§åˆ†ã‹ã‚Šã‚„ã™ã„æ§‹æˆã«æ”¹è‰¯
"""
import argparse
from datetime import datetime
from pathlib import Path

from config import Config
from extractors import DatabaseExtractor, APIExtractor, ProjectExtractor, GitExtractor
from formatters import MarkdownFormatter


class REASpecGenerator:
    def __init__(self, mode='auto'):
        self.mode = mode
        self.config = Config()
        self.output_dir = self.config.OUTPUT_DIR
        self.output_dir.mkdir(exist_ok=True, parents=True)
    
    def generate(self):
        """ä»•æ§˜æ›¸ã‚’ç”Ÿæˆ"""
        print("ğŸš€ REAä»•æ§˜æ›¸ç”Ÿæˆã‚’é–‹å§‹ã—ã¾ã™...")
        
        # ãƒ¢ãƒ¼ãƒ‰åˆ¤å®š
        if self.mode == 'auto':
            self.mode = 'live' if self._check_live_env() else 'static'
        
        print(f"ğŸ“‹ ãƒ¢ãƒ¼ãƒ‰: {self.mode}")
        
        # å„ç¨®æƒ…å ±ã‚’åé›†
        spec_data = {
            'generated_at': datetime.now().isoformat(),
            'mode': self.mode,
            'database': DatabaseExtractor().extract() if self.mode == 'live' else {},
            'api': APIExtractor().extract() if self.mode == 'live' else {},
            'project': ProjectExtractor().extract(),
            'git': GitExtractor().extract()
        }
        
        # Markdownç”Ÿæˆ
        formatter = MarkdownFormatter()
        output = formatter.format(spec_data)
        
        # ãƒ•ã‚¡ã‚¤ãƒ«ä¿å­˜
        filename = f"REA_specification_{datetime.now().strftime('%Y%m%d_%H%M%S')}.md"
        filepath = self.output_dir / filename
        filepath.write_text(output, encoding='utf-8')
        
        # æœ€æ–°ç‰ˆã®ã‚·ãƒ³ãƒœãƒªãƒƒã‚¯ãƒªãƒ³ã‚¯
        latest = self.output_dir / 'latest.md'
        if latest.exists():
            latest.unlink()
        latest.symlink_to(filename)
        
        print(f"âœ… ç”Ÿæˆå®Œäº†: {filepath}")
        print(f"ğŸ“ Claude.aiã« {latest} ã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã—ã¦ãã ã•ã„")
        
        return filepath
    
    def _check_live_env(self):
        """ãƒ©ã‚¤ãƒ–ç’°å¢ƒãŒåˆ©ç”¨å¯èƒ½ã‹ãƒã‚§ãƒƒã‚¯"""
        try:
            # DBæ¥ç¶šãƒ†ã‚¹ãƒˆ
            import psycopg2
            conn = psycopg2.connect(
                dbname=self.config.DB_NAME,
                user=self.config.DB_USER,
                host=self.config.DB_HOST,
                port=self.config.DB_PORT
            )
            conn.close()
            
            # APIç¨¼åƒãƒã‚§ãƒƒã‚¯
            import requests
            requests.get(f"{self.config.API_URL}/docs", timeout=2)
            
            return True
        except:
            return False


def main():
    """ãƒ¡ã‚¤ãƒ³å‡¦ç†"""
    parser = argparse.ArgumentParser(description='REAä»•æ§˜æ›¸ã‚’ç”Ÿæˆ')
    parser.add_argument(
        '--mode',
        choices=['auto', 'live', 'static'],
        default='auto',
        help='å®Ÿè¡Œãƒ¢ãƒ¼ãƒ‰'
    )
    parser.add_argument(
        '--static',
        action='store_true',
        help='é™çš„ãƒ¢ãƒ¼ãƒ‰ã§å®Ÿè¡Œ'
    )
    
    args = parser.parse_args()
    mode = 'static' if args.static else args.mode
    
    generator = REASpecGenerator(mode=mode)
    generator.generate()


if __name__ == '__main__':
    main()

================================================================================
ğŸ“„ ãƒ•ã‚¡ã‚¤ãƒ«: scripts/auto_spec_generator/.env
================================================================================
DATABASE_URL=***MASKED***
DB_HOST=127.0.0.1
DB_PORT=5432
DB_NAME=real_estate_db
DB_USER=rea_user
DB_PASSWORD=***MASKED***


================================================================================
ğŸ“„ ãƒ•ã‚¡ã‚¤ãƒ«: scripts/auto_spec_generator/master_generator.py
================================================================================
# scripts/auto_spec_generator/master_generator.py
"""
REAçµ±åˆä»•æ§˜æ›¸ç”Ÿæˆã‚·ã‚¹ãƒ†ãƒ  - æ”¹å–„ç‰ˆ
å•é¡Œç‚¹ã‚’è§£æ±ºã—ãŸçµ±åˆå®Ÿè¡Œã‚·ã‚¹ãƒ†ãƒ 
"""

import os
import sys
import time
import subprocess
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional
from sqlalchemy import create_engine, inspect
import json

class REAMasterGenerator:
    """REAçµ±åˆä»•æ§˜æ›¸ç”Ÿæˆã‚·ã‚¹ãƒ†ãƒ  - ã‚¨ãƒ©ãƒ¼è€æ€§ãƒ»è‡ªå‹•æ›´æ–°å¯¾å¿œç‰ˆ"""
    
    def __init__(self, base_path: str = "/Users/yaguchimakoto/my_programing/REA"):
        self.base_path = Path(base_path)
        self.cache_dir = self.base_path / "docs" / ".cache"
        self.config_file = self.cache_dir / "generation_config.json"
        self.db_url =***MASKED***
        
        # ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªä½œæˆ
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
    def generate_all(self, force_update: bool = False):
        """çµ±åˆä»•æ§˜æ›¸ç”Ÿæˆ - ã‚¨ãƒ©ãƒ¼è€æ€§å¼·åŒ–ç‰ˆ"""
        print("ğŸš€ REAçµ±åˆä»•æ§˜æ›¸ç”Ÿæˆé–‹å§‹...")
        print(f"ğŸ“ ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆ: {self.base_path}")
        print(f"ğŸ• é–‹å§‹æ™‚åˆ»: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        
        # å‰å›å®Ÿè¡Œæƒ…å ±èª­ã¿è¾¼ã¿
        last_config = self._load_last_config()
        
        try:
            # Phase 1: åŸºæœ¬æ§‹é€ åˆ†æï¼ˆã‚¨ãƒ©ãƒ¼è€æ€§å¼·åŒ–ï¼‰
            print("\nğŸ“Š Phase 1: åŸºæœ¬æ§‹é€ åˆ†æ...")
            basic_success = self._safe_basic_analysis(force_update, last_config)
            
            # Phase 2: è©³ç´°ä»•æ§˜ç”Ÿæˆï¼ˆåŸºæœ¬åˆ†ææˆåŠŸæ™‚ã®ã¿ï¼‰
            print("\nğŸ“‹ Phase 2: è©³ç´°ä»•æ§˜ç”Ÿæˆ...")
            detail_success = self._safe_detail_generation(basic_success, force_update)
            
            # Phase 3: Claudeæœ€é©åŒ–ï¼ˆè©³ç´°ç”ŸæˆæˆåŠŸæ™‚ã®ã¿ï¼‰
            print("\nğŸ¤– Phase 3: Claudeæœ€é©åŒ–ãƒãƒ£ãƒ³ã‚¯...")
            claude_success = self._safe_claude_optimization(detail_success, force_update)
            
            # Phase 4: é€£æºã‚¬ã‚¤ãƒ‰ç”Ÿæˆ
            print("\nğŸ“š Phase 4: Claudeé€£æºã‚¬ã‚¤ãƒ‰...")
            guide_success = self._safe_guide_generation(force_update)
            
            # Phase 5: ã‚·ãƒ§ãƒ¼ãƒˆã‚³ãƒ¼ãƒ‰ç”Ÿæˆï¼ˆæ–°æ©Ÿèƒ½ï¼‰
            print("\nâš¡ Phase 5: ã‚·ãƒ§ãƒ¼ãƒˆã‚³ãƒ¼ãƒ‰ç”Ÿæˆ...")
            shortcode_success = self._generate_shortcodes()
            
            # çµæœã‚µãƒãƒªãƒ¼
            self._print_summary(basic_success, detail_success, claude_success, 
                              guide_success, shortcode_success)
            
            # è¨­å®šä¿å­˜
            self._save_config({
                "last_update": datetime.now().isoformat(),
                "basic_analysis": basic_success,
                "detail_generation": detail_success,
                "claude_optimization": claude_success,
                "guide_generation": guide_success,
                "shortcode_generation": shortcode_success
            })
            
        except KeyboardInterrupt:
            print("\nâš ï¸ ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«ã‚ˆã‚‹ä¸­æ–­")
            sys.exit(1)
        except Exception as e:
            print(f"\nâŒ äºˆæœŸã—ãªã„ã‚¨ãƒ©ãƒ¼: {e}")
            self._emergency_recovery()
    
    def _safe_basic_analysis(self, force_update: bool, last_config: dict) -> bool:
        """åŸºæœ¬æ§‹é€ åˆ†æ - ã‚¨ãƒ©ãƒ¼è€æ€§ç‰ˆ"""
        try:
            # ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒã‚§ãƒƒã‚¯
            if not force_update and self._is_cache_valid("basic_analysis", last_config):
                print("   âœ… ã‚­ãƒ£ãƒƒã‚·ãƒ¥æœ‰åŠ¹ã€åŸºæœ¬åˆ†æã‚’ã‚¹ã‚­ãƒƒãƒ—")
                return True
            
            # DBæ¥ç¶šãƒ†ã‚¹ãƒˆ
            if not self._test_db_connection():
                print("   âš ï¸ DBæ¥ç¶šå¤±æ•—ã€ã‚­ãƒ£ãƒƒã‚·ãƒ¥æƒ…å ±ã‚’ä½¿ç”¨")
                return self._use_cached_basic_analysis()
            
            # main_generator.py å®Ÿè¡Œ
            result = subprocess.run([
                sys.executable, 
                str(self.base_path / "scripts/auto_spec_generator/main_generator.py")
            ], capture_output=True, text=True, cwd=self.base_path)
            
            if result.returncode == 0:
                print("   âœ… åŸºæœ¬æ§‹é€ åˆ†æå®Œäº†")
                self._cache_success("basic_analysis")
                return True
            else:
                print(f"   âŒ åŸºæœ¬åˆ†æã‚¨ãƒ©ãƒ¼: {result.stderr}")
                return self._use_cached_basic_analysis()
                
        except Exception as e:
            print(f"   âŒ åŸºæœ¬åˆ†æä¾‹å¤–: {e}")
            return self._use_cached_basic_analysis()
    
    def _safe_detail_generation(self, basic_success: bool, force_update: bool) -> bool:
        """è©³ç´°ä»•æ§˜ç”Ÿæˆ - ã‚¨ãƒ©ãƒ¼è€æ€§ç‰ˆ"""
        if not basic_success:
            print("   âš ï¸ åŸºæœ¬åˆ†æå¤±æ•—ã€è©³ç´°ç”Ÿæˆã‚’ã‚¹ã‚­ãƒƒãƒ—")
            return False
            
        try:
            # table_detail_generator.py å®Ÿè¡Œ
            result = subprocess.run([
                sys.executable,
                str(self.base_path / "scripts/auto_spec_generator/table_detail_generator.py")
            ], capture_output=True, text=True, cwd=self.base_path)
            
            if result.returncode == 0:
                print("   âœ… è©³ç´°ä»•æ§˜ç”Ÿæˆå®Œäº†")
                return True
            else:
                print(f"   âŒ è©³ç´°ç”Ÿæˆã‚¨ãƒ©ãƒ¼: {result.stderr}")
                return False
                
        except Exception as e:
            print(f"   âŒ è©³ç´°ç”Ÿæˆä¾‹å¤–: {e}")
            return False
    
    def _safe_claude_optimization(self, detail_success: bool, force_update: bool) -> bool:
        """Claudeæœ€é©åŒ– - ã‚¨ãƒ©ãƒ¼è€æ€§ç‰ˆ"""
        if not detail_success:
            print("   âš ï¸ è©³ç´°ç”Ÿæˆå¤±æ•—ã€Claudeæœ€é©åŒ–ã‚’ã‚¹ã‚­ãƒƒãƒ—")
            return False
            
        try:
            # claude_chunk_generator.py å®Ÿè¡Œ
            result = subprocess.run([
                sys.executable,
                str(self.base_path / "scripts/auto_spec_generator/claude_chunk_generator.py")
            ], capture_output=True, text=True, cwd=self.base_path)
            
            if result.returncode == 0:
                print("   âœ… Claudeæœ€é©åŒ–å®Œäº†")
                return True
            else:
                print(f"   âŒ Claudeæœ€é©åŒ–ã‚¨ãƒ©ãƒ¼: {result.stderr}")
                return False
                
        except Exception as e:
            print(f"   âŒ Claudeæœ€é©åŒ–ä¾‹å¤–: {e}")
            return False
    
    def _safe_guide_generation(self, force_update: bool) -> bool:
        """é€£æºã‚¬ã‚¤ãƒ‰ç”Ÿæˆ - ã‚¨ãƒ©ãƒ¼è€æ€§ç‰ˆ"""
        try:
            # claude_integration_generator.py å®Ÿè¡Œ
            result = subprocess.run([
                sys.executable,
                str(self.base_path / "scripts/auto_spec_generator/claude_integration_generator.py")
            ], capture_output=True, text=True, cwd=self.base_path)
            
            if result.returncode == 0:
                print("   âœ… é€£æºã‚¬ã‚¤ãƒ‰ç”Ÿæˆå®Œäº†")
                return True
            else:
                print(f"   âŒ ã‚¬ã‚¤ãƒ‰ç”Ÿæˆã‚¨ãƒ©ãƒ¼: {result.stderr}")
                return False
                
        except Exception as e:
            print(f"   âŒ ã‚¬ã‚¤ãƒ‰ç”Ÿæˆä¾‹å¤–: {e}")
            return False
    
    def _generate_shortcodes(self) -> bool:
        """ã‚·ãƒ§ãƒ¼ãƒˆã‚³ãƒ¼ãƒ‰ç”Ÿæˆ - æ–°æ©Ÿèƒ½"""
        try:
            shortcode_dir = self.base_path / "docs" / "shortcodes"
            shortcode_dir.mkdir(exist_ok=True)
            
            # ã‚·ãƒ§ãƒ¼ãƒˆã‚³ãƒ¼ãƒ‰å®šç¾©
            shortcodes = {
                "@rea-pricing": "docs/claude_chunks/pricing/overview.md",
                "@rea-images": "docs/claude_chunks/images/overview.md", 
                "@rea-location": "docs/claude_chunks/location/overview.md",
                "@rea-building": "docs/claude_chunks/building/overview.md",
                "@rea-api": "docs/claude_chunks/api/overview.md",
                "@rea-dev": "docs/claude_chunks/development/overview.md",
                "@rea-db": "docs/01_database/current_structure.md",
                "@rea-help": "docs/claude_integration/quick_reference.md"
            }
            
            # ã‚·ãƒ§ãƒ¼ãƒˆã‚³ãƒ¼ãƒ‰ã‚¬ã‚¤ãƒ‰ç”Ÿæˆ
            content = f"""# âš¡ REA ã‚·ãƒ§ãƒ¼ãƒˆã‚³ãƒ¼ãƒ‰ - è¶…åŠ¹ç‡Claudeé€£æº

## ğŸ¯ ä½¿ã„æ–¹
```
ğŸ‘¤ [ã‚·ãƒ§ãƒ¼ãƒˆã‚³ãƒ¼ãƒ‰] "[è³ªå•å†…å®¹]"

ä¾‹:
ğŸ‘¤ @rea-pricing "åˆ©å›ã‚Šè¨ˆç®—ã‚’å®Ÿè£…ã—ãŸã„"
ğŸ‘¤ @rea-images "30æšã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰æ©Ÿèƒ½ã®ãƒã‚°ä¿®æ­£"
ğŸ‘¤ @rea-api "æ–°ã—ã„ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆè¿½åŠ æ–¹æ³•"
```

## âš¡ ã‚·ãƒ§ãƒ¼ãƒˆã‚³ãƒ¼ãƒ‰ä¸€è¦§

| ã‚·ãƒ§ãƒ¼ãƒˆã‚³ãƒ¼ãƒ‰ | æ©Ÿèƒ½ | å¯¾è±¡ãƒ•ã‚¡ã‚¤ãƒ« |
|---------------|------|-------------|
"""
            
            for code, file_path in shortcodes.items():
                function_name = code.replace("@rea-", "").title()
                content += f"| `{code}` | {function_name} | {file_path} |\n"
            
            content += f"""

## ğŸš€ å®Ÿéš›ã®ä½¿ç”¨ä¾‹

### ğŸ’° ä¾¡æ ¼æ©Ÿèƒ½
```
ğŸ‘¤ @rea-pricing "åˆ©å›ã‚Šè¨ˆç®—APIã®å®Ÿè£…æ–¹æ³•"
â†’ Claude ãŒ docs/claude_chunks/pricing/overview.md ã‚’ç¢ºèªã—ã¦å›ç­”
```

### ğŸ“¸ ç”»åƒæ©Ÿèƒ½
```
ğŸ‘¤ @rea-images "ç”»åƒä¸€æ‹¬å‰Šé™¤æ©Ÿèƒ½ã®å®Ÿè£…"
â†’ Claude ãŒ docs/claude_chunks/images/overview.md ã‚’ç¢ºèªã—ã¦å›ç­”
```

### ğŸ”§ ãƒˆãƒ©ãƒ–ãƒ«å¯¾å¿œ
```
ğŸ‘¤ @rea-dev "PostgreSQLæ¥ç¶šã‚¨ãƒ©ãƒ¼ã®è§£æ±ºæ–¹æ³•"
â†’ Claude ãŒ docs/claude_chunks/development/overview.md ã‚’ç¢ºèªã—ã¦å›ç­”
```

---
ç”Ÿæˆæ—¥æ™‚: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
"""
            
            with open(shortcode_dir / "README.md", 'w', encoding='utf-8') as f:
                f.write(content)
            
            # å±•é–‹ç”¨ã‚¹ã‚¯ãƒªãƒ—ãƒˆç”Ÿæˆ
            expand_script = f'''#!/usr/bin/env python3
"""REA ã‚·ãƒ§ãƒ¼ãƒˆã‚³ãƒ¼ãƒ‰å±•é–‹ã‚¹ã‚¯ãƒªãƒ—ãƒˆ"""

shortcodes = {shortcodes}

def expand_shortcode(text):
    """ã‚·ãƒ§ãƒ¼ãƒˆã‚³ãƒ¼ãƒ‰ã‚’å±•é–‹"""
    for code, file_path in shortcodes.items():
        if code in text:
            expanded = f'REAã«ã¤ã„ã¦è³ªå•ãŒã‚ã‚Šã¾ã™ã€‚ã¾ãš {{file_path}} ã‚’ç¢ºèªã—ã¦ã‹ã‚‰ã€ä»¥ä¸‹ã«ã¤ã„ã¦å›ç­”ã—ã¦ãã ã•ã„: {{text.replace(code, "").strip()}}'
            return expanded
    return text

if __name__ == "__main__":
    import sys
    if len(sys.argv) > 1:
        result = expand_shortcode(" ".join(sys.argv[1:]))
        print(result)
    else:
        print("ä½¿ã„æ–¹: python expand_shortcode.py @rea-pricing 'åˆ©å›ã‚Šè¨ˆç®—ã«ã¤ã„ã¦'")
'''
            
            with open(shortcode_dir / "expand_shortcode.py", 'w', encoding='utf-8') as f:
                f.write(expand_script)
            
            print("   âœ… ã‚·ãƒ§ãƒ¼ãƒˆã‚³ãƒ¼ãƒ‰ç”Ÿæˆå®Œäº†")
            return True
            
        except Exception as e:
            print(f"   âŒ ã‚·ãƒ§ãƒ¼ãƒˆã‚³ãƒ¼ãƒ‰ç”Ÿæˆä¾‹å¤–: {e}")
            return False
    
    def _test_db_connection(self) -> bool:
        """ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ¥ç¶šãƒ†ã‚¹ãƒˆ"""
        try:
            engine = create_engine(self.db_url)
            with engine.connect() as conn:
                result = conn.execute("SELECT 1")
                return True
        except Exception:
            return False
    
    def _use_cached_basic_analysis(self) -> bool:
        """ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã•ã‚ŒãŸåŸºæœ¬åˆ†ææƒ…å ±ã‚’ä½¿ç”¨"""
        cache_file = self.cache_dir / "basic_analysis_cache.json"
        if cache_file.exists():
            print("   ğŸ“„ ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‹ã‚‰åŸºæœ¬åˆ†ææƒ…å ±ã‚’å¾©å…ƒ")
            return True
        else:
            print("   âŒ ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚‚åˆ©ç”¨ä¸å¯")
            return False
    
    def _is_cache_valid(self, cache_type: str, last_config: dict, 
                       valid_hours: int = 24) -> bool:
        """ã‚­ãƒ£ãƒƒã‚·ãƒ¥æœ‰åŠ¹æ€§ãƒã‚§ãƒƒã‚¯"""
        if not last_config:
            return False
            
        last_update = last_config.get("last_update")
        if not last_update:
            return False
            
        try:
            last_time = datetime.fromisoformat(last_update)
            return datetime.now() - last_time < timedelta(hours=valid_hours)
        except:
            return False
    
    def _cache_success(self, operation: str):
        """æˆåŠŸæƒ…å ±ã‚’ã‚­ãƒ£ãƒƒã‚·ãƒ¥"""
        cache_file = self.cache_dir / f"{operation}_cache.json"
        cache_data = {
            "timestamp": datetime.now().isoformat(),
            "success": True
        }
        with open(cache_file, 'w') as f:
            json.dump(cache_data, f)
    
    def _load_last_config(self) -> dict:
        """å‰å›å®Ÿè¡Œè¨­å®šã‚’èª­ã¿è¾¼ã¿"""
        if self.config_file.exists():
            try:
                with open(self.config_file, 'r') as f:
                    return json.load(f)
            except:
                return {}
        return {}
    
    def _save_config(self, config: dict):
        """å®Ÿè¡Œè¨­å®šã‚’ä¿å­˜"""
        with open(self.config_file, 'w') as f:
            json.dump(config, f, indent=2)
    
    def _emergency_recovery(self):
        """ç·Šæ€¥æ™‚å¾©æ—§å‡¦ç†"""
        print("\nğŸš¨ ç·Šæ€¥å¾©æ—§ãƒ¢ãƒ¼ãƒ‰")
        print("ğŸ“‹ åˆ©ç”¨å¯èƒ½ãªå¾©æ—§ã‚ªãƒ—ã‚·ãƒ§ãƒ³:")
        print("   1. ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‹ã‚‰ã®å¾©å…ƒ")
        print("   2. éƒ¨åˆ†çš„ãªå†ç”Ÿæˆ")
        print("   3. æœ€å°é™ã®ä»•æ§˜æ›¸ç”Ÿæˆ")
        
        # æœ€å°é™ã®ä»•æ§˜æ›¸ç”Ÿæˆ
        try:
            minimal_content = f"""# REA ã‚·ã‚¹ãƒ†ãƒ  - ç·Šæ€¥æ™‚ä»•æ§˜æ›¸

## âš ï¸ æ³¨æ„
ã“ã®ä»•æ§˜æ›¸ã¯ç·Šæ€¥å¾©æ—§ã«ã‚ˆã‚Šç”Ÿæˆã•ã‚Œã¾ã—ãŸã€‚
å®Œå…¨ãªä»•æ§˜æ›¸ç”Ÿæˆã¯ä»¥ä¸‹ã‚³ãƒãƒ³ãƒ‰ã§å®Ÿè¡Œã—ã¦ãã ã•ã„ï¼š

```bash
python scripts/auto_spec_generator/master_generator.py --force
```

## ğŸ¯ åŸºæœ¬æƒ…å ±
- ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆ: REA (Real Estate Automation)
- ç”Ÿæˆæ—¥æ™‚: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
- çŠ¶æ…‹: ç·Šæ€¥å¾©æ—§ãƒ¢ãƒ¼ãƒ‰

## ğŸ”— é‡è¦ãªURL
- APIæ–‡æ›¸: http://localhost:8005/docs
- ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆ: /Users/yaguchimakoto/my_programing/REA

## ğŸš€ ã‚¯ã‚¤ãƒƒã‚¯ã‚¹ã‚¿ãƒ¼ãƒˆ
```bash
#cd /Users/yaguchimakoto/my_programing/REA
source venv/bin/activate
#cd rea-api
uvicorn app.main:app --reload --host 0.0.0.0 --port 8005
```
"""
            
            emergency_file = self.base_path / "docs" / "EMERGENCY_README.md"
            with open(emergency_file, 'w', encoding='utf-8') as f:
                f.write(minimal_content)
            
            print(f"âœ… ç·Šæ€¥æ™‚ä»•æ§˜æ›¸ã‚’ç”Ÿæˆ: {emergency_file}")
            
        except Exception as e:
            print(f"âŒ ç·Šæ€¥å¾©æ—§ã‚‚å¤±æ•—: {e}")
    
    def _print_summary(self, basic: bool, detail: bool, claude: bool, 
                      guide: bool, shortcode: bool):
        """å®Ÿè¡Œçµæœã‚µãƒãƒªãƒ¼"""
        print(f"\nğŸ“‹ REAçµ±åˆä»•æ§˜æ›¸ç”Ÿæˆçµæœ:")
        print("â”€" * 50)
        print(f"ğŸ“Š Phase 1 åŸºæœ¬æ§‹é€ åˆ†æ:     {'âœ… æˆåŠŸ' if basic else 'âŒ å¤±æ•—'}")
        print(f"ğŸ“‹ Phase 2 è©³ç´°ä»•æ§˜ç”Ÿæˆ:     {'âœ… æˆåŠŸ' if detail else 'âŒ å¤±æ•—'}")
        print(f"ğŸ¤– Phase 3 Claudeæœ€é©åŒ–:     {'âœ… æˆåŠŸ' if claude else 'âŒ å¤±æ•—'}")
        print(f"ğŸ“š Phase 4 é€£æºã‚¬ã‚¤ãƒ‰:       {'âœ… æˆåŠŸ' if guide else 'âŒ å¤±æ•—'}")
        print(f"âš¡ Phase 5 ã‚·ãƒ§ãƒ¼ãƒˆã‚³ãƒ¼ãƒ‰:   {'âœ… æˆåŠŸ' if shortcode else 'âŒ å¤±æ•—'}")
        
        success_count = sum([basic, detail, claude, guide, shortcode])
        print(f"\nğŸ¯ æˆåŠŸç‡: {success_count}/5 ({success_count/5*100:.0f}%)")
        
        if success_count >= 3:
            print("ğŸ‰ ååˆ†ãªä»•æ§˜æ›¸ãŒç”Ÿæˆã•ã‚Œã¾ã—ãŸï¼")
            if shortcode:
                print("âš¡ ã‚·ãƒ§ãƒ¼ãƒˆã‚³ãƒ¼ãƒ‰ãŒåˆ©ç”¨å¯èƒ½: docs/shortcodes/README.md")
        else:
            print("âš ï¸ ä¸€éƒ¨å¤±æ•—ã€å€‹åˆ¥å®Ÿè¡Œã‚’æ¨å¥¨")
            print("ğŸ”§ å€‹åˆ¥å®Ÿè¡Œæ–¹æ³•:")
            if not basic:
                print("   python scripts/auto_spec_generator/main_generator.py")
            if not detail:
                print("   python scripts/auto_spec_generator/table_detail_generator.py")

def main():
    """ãƒ¡ã‚¤ãƒ³å®Ÿè¡Œé–¢æ•°"""
    import argparse
    
    parser = argparse.ArgumentParser(description='REAçµ±åˆä»•æ§˜æ›¸ç”Ÿæˆã‚·ã‚¹ãƒ†ãƒ ')
    parser.add_argument('--force', action='store_true', 
                       help='ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’ç„¡è¦–ã—ã¦å¼·åˆ¶æ›´æ–°')
    parser.add_argument('--quick', action='store_true',
                       help='ã‚¯ã‚¤ãƒƒã‚¯æ›´æ–°ï¼ˆå·®åˆ†ã®ã¿ï¼‰')
    
    args = parser.parse_args()
    
    generator = REAMasterGenerator()
    generator.generate_all(force_update=args.force)

if __name__ == "__main__":
    main()

================================================================================
ğŸ“„ ãƒ•ã‚¡ã‚¤ãƒ«: scripts/auto_spec_generator/table_detail_generator.py
================================================================================
# scripts/auto_spec_generator/table_detail_generator.py
from pathlib import Path
from datetime import datetime
from typing import Dict, List, Optional, Any
from sqlalchemy import create_engine, inspect, text
import json

class TableDetailGenerator:
    """åˆ†å‰²æ¸ˆã¿ãƒ†ãƒ¼ãƒ–ãƒ«ã®è©³ç´°ä»•æ§˜ç”Ÿæˆå™¨"""
    
    def __init__(self):
        self.base_path = Path("/Users/yaguchimakoto/my_programing/REA")
        self.output_dir = self.base_path / "docs"
        self.db_url =***MASKED***
        self.engine = create_engine(self.db_url)
        
        # åˆ†å‰²æ¸ˆã¿ãƒ†ãƒ¼ãƒ–ãƒ«ã®åˆ†é¡
        self.table_groups = {
            'core': {
                'tables': ['properties'],
                'icon': 'ğŸ¢',
                'title': 'åŸºæœ¬æƒ…å ±',
                'description': 'ç‰©ä»¶ã®æ ¸ã¨ãªã‚‹åŸºæœ¬æƒ…å ±'
            },
            'pricing': {
                'tables': ['properties_pricing'],
                'icon': 'ğŸ’°',
                'title': 'ä¾¡æ ¼ãƒ»åç›Š',
                'description': 'ä¾¡æ ¼ãƒ»è³ƒæ–™ãƒ»åˆ©å›ã‚Šç­‰ã®åç›Šæƒ…å ±'
            },
            'location': {
                'tables': ['properties_location', 'properties_transportation'],
                'icon': 'ğŸ“',
                'title': 'æ‰€åœ¨åœ°ãƒ»äº¤é€š',
                'description': 'ä½æ‰€ãƒ»é§…ãƒ»äº¤é€šã‚¢ã‚¯ã‚»ã‚¹æƒ…å ±'
            },
            'images': {
                'tables': ['properties_images'],
                'icon': 'ğŸ“¸',
                'title': 'ç”»åƒç®¡ç†',
                'description': 'ç‰©ä»¶ç”»åƒã®ç®¡ç†ãƒ»è¡¨ç¤ºæ©Ÿèƒ½'
            },
            'building': {
                'tables': ['properties_building', 'properties_floor_plans'],
                'icon': 'ğŸ—ï¸',
                'title': 'å»ºç‰©æƒ…å ±',
                'description': 'å»ºç‰©æ§‹é€ ãƒ»é–“å–ã‚Šãƒ»ä»•æ§˜æƒ…å ±'
            },
            'contract': {
                'tables': ['properties_contract'],
                'icon': 'ğŸ“‹',
                'title': 'å¥‘ç´„æƒ…å ±',
                'description': 'å¥‘ç´„æ¡ä»¶ãƒ»å…¥å±…ãƒ»å–å¼•æƒ…å ±'
            },
            'land': {
                'tables': ['properties_roads', 'properties_other'],
                'icon': 'ğŸï¸',
                'title': 'åœŸåœ°ãƒ»æ³•ä»¤',
                'description': 'åœŸåœ°æƒ…å ±ãƒ»ç”¨é€”åœ°åŸŸãƒ»æ³•çš„åˆ¶é™'
            },
            'facilities': {
                'tables': ['properties_facilities'],
                'icon': 'ğŸ«',
                'title': 'å‘¨è¾ºæ–½è¨­',
                'description': 'å­¦æ ¡ãƒ»ç—…é™¢ãƒ»å•†æ¥­æ–½è¨­ç­‰ã®å‘¨è¾ºç’°å¢ƒ'
            }
        }
    
    def generate_all_table_details(self):
        """å…¨ãƒ†ãƒ¼ãƒ–ãƒ«ã®è©³ç´°ä»•æ§˜ã‚’ç”Ÿæˆ"""
        print("ğŸš€ ãƒ†ãƒ¼ãƒ–ãƒ«è©³ç´°ä»•æ§˜ç”Ÿæˆé–‹å§‹...")
        
        try:
            inspector = inspect(self.engine)
            
            # å„æ©Ÿèƒ½ã‚°ãƒ«ãƒ¼ãƒ—ã®è©³ç´°ä»•æ§˜ç”Ÿæˆ
            for group_name, group_info in self.table_groups.items():
                print(f"ğŸ“Š {group_info['icon']} {group_info['title']} ç”Ÿæˆä¸­...")
                self._generate_group_specs(group_name, group_info, inspector)
            
            # ãƒ†ãƒ¼ãƒ–ãƒ«ä¸€è¦§ã®æ›´æ–°
            self._generate_tables_overview(inspector)
            
            print("âœ… å…¨ãƒ†ãƒ¼ãƒ–ãƒ«è©³ç´°ä»•æ§˜ç”Ÿæˆå®Œäº†ï¼")
            self._print_summary()
            
        except Exception as e:
            print(f"âŒ ã‚¨ãƒ©ãƒ¼: {e}")
            import traceback
            traceback.print_exc()
    
    def _generate_group_specs(self, group_name: str, group_info: dict, inspector):
        """æ©Ÿèƒ½ã‚°ãƒ«ãƒ¼ãƒ—ã®ä»•æ§˜ç”Ÿæˆ"""
        # ã‚°ãƒ«ãƒ¼ãƒ—ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªä½œæˆ
        group_dir = self.output_dir / "01_database" / "tables" / group_name
        group_dir.mkdir(parents=True, exist_ok=True)
        
        # ã‚°ãƒ«ãƒ¼ãƒ—æ¦‚è¦ç”Ÿæˆ
        self._generate_group_overview(group_name, group_info, group_dir)
        
        # å„ãƒ†ãƒ¼ãƒ–ãƒ«ã®è©³ç´°ä»•æ§˜ç”Ÿæˆ
        for table_name in group_info['tables']:
            if table_name in inspector.get_table_names():
                self._generate_single_table_detail(table_name, group_name, group_dir, inspector)
    
    def _generate_group_overview(self, group_name: str, group_info: dict, group_dir: Path):
        """æ©Ÿèƒ½ã‚°ãƒ«ãƒ¼ãƒ—æ¦‚è¦ç”Ÿæˆ"""
        content = f"""# {group_info['icon']} {group_info['title']} ãƒ†ãƒ¼ãƒ–ãƒ«ç¾¤

## ğŸ“‹ æ¦‚è¦
{group_info['description']}

## ğŸ—‚ï¸ å«ã¾ã‚Œã‚‹ãƒ†ãƒ¼ãƒ–ãƒ«
"""
        
        for table_name in group_info['tables']:
            try:
                inspector = inspect(self.engine)
                if table_name in inspector.get_table_names():
                    columns = inspector.get_columns(table_name)
                    record_count = self._get_record_count(table_name)
                    content += f"- [{table_name}]({table_name}.md) - {len(columns)}ã‚«ãƒ©ãƒ , {record_count:,}ãƒ¬ã‚³ãƒ¼ãƒ‰\n"
            except:
                content += f"- [{table_name}]({table_name}.md) - è©³ç´°ä¸æ˜\n"
        
        content += f"""
## ğŸ¯ ä¸»ãªç”¨é€”
{self._get_group_usage(group_name)}

## ğŸ”— é–¢é€£ãƒ†ãƒ¼ãƒ–ãƒ«
{self._get_related_tables(group_name)}

## ğŸš€ ã‚ˆãä½¿ã†ã‚¯ã‚¨ãƒªä¾‹
{self._get_common_queries(group_name)}
"""
        
        with open(group_dir / "README.md", 'w', encoding='utf-8') as f:
            f.write(content)
    
    def _generate_single_table_detail(self, table_name: str, group_name: str, group_dir: Path, inspector):
        """å˜ä¸€ãƒ†ãƒ¼ãƒ–ãƒ«ã®è©³ç´°ä»•æ§˜ç”Ÿæˆ"""
        columns = inspector.get_columns(table_name)
        foreign_keys = inspector.get_foreign_keys(table_name)
        indexes = inspector.get_indexes(table_name)
        
        # ãƒ¬ã‚³ãƒ¼ãƒ‰æ•°ãƒ»ã‚µã‚¤ã‚ºå–å¾—
        record_count = self._get_record_count(table_name)
        table_size = self._get_table_size(table_name)
        
        content = f"""# {self.table_groups[group_name]['icon']} {table_name} ãƒ†ãƒ¼ãƒ–ãƒ«è©³ç´°ä»•æ§˜

## ğŸ“‹ åŸºæœ¬æƒ…å ±
- **ãƒ†ãƒ¼ãƒ–ãƒ«å**: `{table_name}`
- **æ©Ÿèƒ½ã‚°ãƒ«ãƒ¼ãƒ—**: {self.table_groups[group_name]['title']}
- **ãƒ¬ã‚³ãƒ¼ãƒ‰æ•°**: {record_count:,}ä»¶
- **ãƒ†ãƒ¼ãƒ–ãƒ«ã‚µã‚¤ã‚º**: {table_size:.2f}MB
- **ã‚«ãƒ©ãƒ æ•°**: {len(columns)}

## ğŸ¯ ãƒ†ãƒ¼ãƒ–ãƒ«ã®å½¹å‰²
{self._get_table_purpose_detailed(table_name)}

## ğŸ“Š ã‚«ãƒ©ãƒ è©³ç´°ä»•æ§˜

| No | ã‚«ãƒ©ãƒ å | ãƒ‡ãƒ¼ã‚¿å‹ | NULL | ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ | èª¬æ˜ | å‚™è€ƒ |
|----|----------|----------|------|------------|------|------|
"""
        
        for i, column in enumerate(columns, 1):
            null_ok = "âœ…" if column['nullable'] else "âŒ"
            default = self._format_default(column.get('default'))
            description = self._get_column_description_detailed(table_name, column['name'])
            notes = self._get_column_notes(table_name, column['name'])
            
            content += f"| {i} | `{column['name']}` | {column['type']} | {null_ok} | {default} | {description} | {notes} |\n"
        
        # åˆ¶ç´„æƒ…å ±
        content += self._generate_constraints_section(table_name, foreign_keys, indexes)
        
        # ä½¿ç”¨ä¾‹
        content += self._generate_usage_examples(table_name, group_name)
        
        # ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æƒ…å ±
        content += self._generate_performance_info(table_name)
        
        # APIé€£æºæƒ…å ±
        content += self._generate_api_integration_info(table_name, group_name)
        
        with open(group_dir / f"{table_name}.md", 'w', encoding='utf-8') as f:
            f.write(content)
        
        print(f"   âœ… {table_name} è©³ç´°ä»•æ§˜ç”Ÿæˆå®Œäº†")
    
    def _generate_constraints_section(self, table_name: str, foreign_keys: list, indexes: list) -> str:
        """åˆ¶ç´„ãƒ»ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹æƒ…å ±ã‚»ã‚¯ã‚·ãƒ§ãƒ³ç”Ÿæˆ"""
        content = "\n## ğŸ”— åˆ¶ç´„ãƒ»ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹æƒ…å ±\n"
        
        # å¤–éƒ¨ã‚­ãƒ¼
        if foreign_keys:
            content += "\n### å¤–éƒ¨ã‚­ãƒ¼åˆ¶ç´„\n"
            for fk in foreign_keys:
                constraint_name = fk.get('name', 'unnamed')
                local_col = ', '.join(fk['constrained_columns'])
                foreign_col = f"{fk['referred_table']}.{', '.join(fk['referred_columns'])}"
                content += f"- **{constraint_name}**: `{local_col}` â†’ `{foreign_col}`\n"
        
        # ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
        if indexes:
            content += "\n### ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹\n"
            for idx in indexes:
                idx_type = "UNIQUE" if idx.get('unique') else "INDEX"
                columns = ', '.join(idx['column_names'])
                content += f"- **{idx['name']}** ({idx_type}): `{columns}`\n"
        
        return content
    
    def _generate_usage_examples(self, table_name: str, group_name: str) -> str:
        """ä½¿ç”¨ä¾‹ã‚»ã‚¯ã‚·ãƒ§ãƒ³ç”Ÿæˆ"""
        content = "\n## ğŸ’¾ ä½¿ç”¨ä¾‹\n"
        
        examples = self._get_usage_examples_by_table(table_name, group_name)
        
        for example_title, sql_code in examples.items():
            content += f"\n### {example_title}\n```sql\n{sql_code}\n```\n"
        
        return content
    
    def _generate_performance_info(self, table_name: str) -> str:
        """ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æƒ…å ±ã‚»ã‚¯ã‚·ãƒ§ãƒ³ç”Ÿæˆ"""
        content = "\n## ğŸ“ˆ ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æƒ…å ±\n"
        
        # åŸºæœ¬çµ±è¨ˆ
        record_count = self._get_record_count(table_name)
        table_size = self._get_table_size(table_name)
        
        content += f"- **ãƒ¬ã‚³ãƒ¼ãƒ‰æ•°**: {record_count:,}ä»¶\n"
        content += f"- **ãƒ†ãƒ¼ãƒ–ãƒ«ã‚µã‚¤ã‚º**: {table_size:.2f}MB\n"
        content += f"- **å¹³å‡ãƒ¬ã‚³ãƒ¼ãƒ‰ã‚µã‚¤ã‚º**: {(table_size * 1024 * 1024 / max(record_count, 1)):.0f}bytes\n"
        
        # ã‚¯ã‚¨ãƒªãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æ¨å®š
        if record_count > 10000:
            content += "- **æ³¨æ„**: å¤§é‡ãƒ‡ãƒ¼ã‚¿ã®ãŸã‚ã€WHEREå¥ã¨ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã®ä½¿ç”¨ã‚’æ¨å¥¨\n"
        elif record_count > 1000:
            content += "- **æ¨å¥¨**: åŠ¹ç‡çš„ãªæ¤œç´¢ã®ãŸã‚ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ä½¿ç”¨ã‚’æ¨å¥¨\n"
        else:
            content += "- **çŠ¶æ³**: å°è¦æ¨¡ãƒ‡ãƒ¼ã‚¿ã®ãŸã‚é«˜é€Ÿã‚¢ã‚¯ã‚»ã‚¹å¯èƒ½\n"
        
        return content
    
    def _generate_api_integration_info(self, table_name: str, group_name: str) -> str:
        """APIé€£æºæƒ…å ±ã‚»ã‚¯ã‚·ãƒ§ãƒ³ç”Ÿæˆ"""
        content = "\n## ğŸ”Œ APIé€£æºæƒ…å ±\n"
        
        # å¯¾å¿œã™ã‚‹APIã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆ
        endpoints = self._get_related_api_endpoints(table_name, group_name)
        
        if endpoints:
            content += "### é–¢é€£APIã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆ\n"
            for endpoint in endpoints:
                content += f"- `{endpoint['method']} {endpoint['path']}` - {endpoint['description']}\n"
        
        # ä½¿ç”¨ä¾‹
        content += "\n### APIä½¿ç”¨ä¾‹\n"
        content += f"```bash\n# {table_name} ãƒ‡ãƒ¼ã‚¿å–å¾—\n"
        content += f"curl http://localhost:8005/api/v1/{group_name}/\n```\n"
        
        return content
    
    def _get_record_count(self, table_name: str) -> int:
        """ãƒ¬ã‚³ãƒ¼ãƒ‰æ•°å–å¾—"""
        try:
            with self.engine.connect() as conn:
                result = conn.execute(text(f"SELECT COUNT(*) FROM {table_name}"))
                return result.scalar()
        except:
            return 0
    
    def _get_table_size(self, table_name: str) -> float:
        """ãƒ†ãƒ¼ãƒ–ãƒ«ã‚µã‚¤ã‚ºå–å¾—ï¼ˆMBï¼‰"""
        try:
            with self.engine.connect() as conn:
                result = conn.execute(text(f"""
                    SELECT pg_total_relation_size('{table_name}') / (1024.0 * 1024.0) as size_mb
                """))
                return result.scalar() or 0.0
        except:
            return 0.0
    
    def _format_default(self, default) -> str:
        """ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ"""
        if default is None:
            return "-"
        return str(default)[:20] + "..." if len(str(default)) > 20 else str(default)
    
    def _get_table_purpose_detailed(self, table_name: str) -> str:
        """ãƒ†ãƒ¼ãƒ–ãƒ«ã®è©³ç´°ãªå½¹å‰²èª¬æ˜"""
        purposes = {
            'properties': 'ç‰©ä»¶ã®æ ¸ã¨ãªã‚‹åŸºæœ¬æƒ…å ±ã‚’ç®¡ç†ã€‚ä»–ã®å…¨ã¦ã®æ©Ÿèƒ½ãƒ†ãƒ¼ãƒ–ãƒ«ã®åŸºç‚¹ã¨ãªã‚‹é‡è¦ãªãƒ†ãƒ¼ãƒ–ãƒ«ã€‚',
            'properties_pricing': 'ç‰©ä»¶ã®ä¾¡æ ¼ãƒ»è³ƒæ–™ãƒ»åˆ©å›ã‚Šç­‰ã®åç›Šã«é–¢ã™ã‚‹æƒ…å ±ã‚’ç®¡ç†ã€‚æŠ•è³‡åˆ¤æ–­ã«å¿…è¦ãªæ•°å€¤ãƒ‡ãƒ¼ã‚¿ãŒé›†ç´„ã•ã‚Œã¦ã„ã‚‹ã€‚',
            'properties_location': 'ç‰©ä»¶ã®ä½æ‰€ãƒ»æ‰€åœ¨åœ°æƒ…å ±ã‚’ç®¡ç†ã€‚éƒµä¾¿ç•ªå·ãƒ»ä½æ‰€ãƒ»ç·¯åº¦çµŒåº¦ç­‰ã®ä½ç½®ç‰¹å®šã«å¿…è¦ãªãƒ‡ãƒ¼ã‚¿ã‚’æ ¼ç´ã€‚',
            'properties_transportation': 'ç‰©ä»¶ã®äº¤é€šã‚¢ã‚¯ã‚»ã‚¹æƒ…å ±ã‚’ç®¡ç†ã€‚æœ€å¯„ã‚Šé§…ãƒ»è·¯ç·šãƒ»å¾’æ­©æ™‚é–“ãƒ»ãƒã‚¹æƒ…å ±ç­‰ã‚’æ ¼ç´ã€‚',
            'properties_images': 'ç‰©ä»¶ã®ç”»åƒæƒ…å ±ã‚’ç®¡ç†ã€‚å¤–è¦³ãƒ»é–“å–ã‚Šãƒ»å®¤å†…å†™çœŸç­‰ã®ç”»åƒãƒ•ã‚¡ã‚¤ãƒ«ã¨é–¢é€£æƒ…å ±ã‚’æ ¼ç´ã€‚',
            'properties_building': 'å»ºç‰©ã®æ§‹é€ ãƒ»ä»•æ§˜æƒ…å ±ã‚’ç®¡ç†ã€‚å»ºç¯‰å¹´ãƒ»æ§‹é€ ãƒ»éšæ•°ãƒ»ç®¡ç†æƒ…å ±ç­‰ã®å»ºç‰©å›ºæœ‰ã®ãƒ‡ãƒ¼ã‚¿ã‚’æ ¼ç´ã€‚',
            'properties_floor_plans': 'ç‰©ä»¶ã®é–“å–ã‚Šè©³ç´°æƒ…å ±ã‚’ç®¡ç†ã€‚å„éƒ¨å±‹ã®ç¨®é¡ãƒ»ç•³æ•°ãƒ»éšæ•°ç­‰ã®è©³ç´°ãªé–“å–ã‚Šãƒ‡ãƒ¼ã‚¿ã‚’æ ¼ç´ã€‚',
            'properties_contract': 'å¥‘ç´„ãƒ»å–å¼•ã«é–¢ã™ã‚‹æƒ…å ±ã‚’ç®¡ç†ã€‚å¥‘ç´„æ¡ä»¶ãƒ»å…¥å±…æ™‚æœŸãƒ»ä»²ä»‹æ‰‹æ•°æ–™ç­‰ã®å–å¼•æ¡ä»¶ã‚’æ ¼ç´ã€‚',
            'properties_facilities': 'ç‰©ä»¶å‘¨è¾ºã®æ–½è¨­æƒ…å ±ã‚’ç®¡ç†ã€‚å­¦æ ¡ãƒ»ç—…é™¢ãƒ»å•†æ¥­æ–½è¨­ç­‰ã¸ã®è·é›¢ãƒ»ã‚¢ã‚¯ã‚»ã‚¹æƒ…å ±ã‚’æ ¼ç´ã€‚',
            'properties_roads': 'ç‰©ä»¶ã®æ¥é“æƒ…å ±ã‚’ç®¡ç†ã€‚é“è·¯ã®æ–¹å‘ãƒ»å¹…å“¡ãƒ»ç¨®åˆ¥ç­‰ã®æ³•çš„è¦ä»¶ã«é–¢ã‚ã‚‹é‡è¦ãªãƒ‡ãƒ¼ã‚¿ã‚’æ ¼ç´ã€‚',
            'properties_other': 'ãã®ä»–ã®ç‰©ä»¶é–¢é€£æƒ…å ±ã‚’ç®¡ç†ã€‚ç”¨é€”åœ°åŸŸãƒ»åœ°å‹¢ãƒ»æ³•çš„åˆ¶é™ç­‰ã®åˆ†é¡å›°é›£ãªæƒ…å ±ã‚’æ ¼ç´ã€‚'
        }
        return purposes.get(table_name, 'ã“ã®ãƒ†ãƒ¼ãƒ–ãƒ«ã®è©³ç´°ãªç”¨é€”ã¯åˆ†æä¸­ã§ã™ã€‚')
    
    def _get_column_description_detailed(self, table_name: str, column_name: str) -> str:
        """ã‚«ãƒ©ãƒ ã®è©³ç´°èª¬æ˜"""
        # column_labelsãƒ†ãƒ¼ãƒ–ãƒ«ã‹ã‚‰æ—¥æœ¬èªèª¬æ˜ã‚’å–å¾—
        try:
            with self.engine.connect() as conn:
                result = conn.execute(text("""
                    SELECT japanese_label, description 
                    FROM column_labels 
                    WHERE table_name = :table_name AND column_name = :column_name
                """), {"table_name": table_name, "column_name": column_name})
                row = result.fetchone()
                if row:
                    return row.description or row.japanese_label
        except:
            pass
        
        # ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: ã‚«ãƒ©ãƒ åã‹ã‚‰æ¨æ¸¬
        return self._infer_column_description(column_name)
    
    def _get_column_notes(self, table_name: str, column_name: str) -> str:
        """ã‚«ãƒ©ãƒ ã®å‚™è€ƒãƒ»æ³¨æ„äº‹é …"""
        # ç‰¹åˆ¥ãªæ³¨æ„ãŒå¿…è¦ãªã‚«ãƒ©ãƒ 
        special_notes = {
            'id': 'ãƒ—ãƒ©ã‚¤ãƒãƒªãƒ¼ã‚­ãƒ¼',
            'property_id': 'å¤–éƒ¨ã‚­ãƒ¼',
            'created_at': 'è‡ªå‹•è¨­å®š',
            'updated_at': 'è‡ªå‹•æ›´æ–°',
            'homes_record_id': 'ãƒ›ãƒ¼ãƒ ã‚ºé€£æºç”¨',
            'price': 'å††å˜ä½',
            'yield': '%å˜ä½'
        }
        
        return special_notes.get(column_name, '')
    
    def _infer_column_description(self, column_name: str) -> str:
        """ã‚«ãƒ©ãƒ åã‹ã‚‰èª¬æ˜ã‚’æ¨æ¸¬"""
        descriptions = {
            'id': 'ãƒ¬ã‚³ãƒ¼ãƒ‰è­˜åˆ¥ID',
            'property_id': 'ç‰©ä»¶IDï¼ˆå¤–éƒ¨ã‚­ãƒ¼ï¼‰',
            'price': 'ä¾¡æ ¼ãƒ»è³ƒæ–™',
            'address': 'ä½æ‰€',
            'name': 'åç§°',
            'type': 'ç¨®åˆ¥ãƒ»ã‚¿ã‚¤ãƒ—',
            'date': 'æ—¥ä»˜',
            'created_at': 'ä½œæˆæ—¥æ™‚',
            'updated_at': 'æ›´æ–°æ—¥æ™‚'
        }
        
        for key, desc in descriptions.items():
            if key in column_name.lower():
                return desc
        
        return 'è©³ç´°èª¬æ˜ã¯æº–å‚™ä¸­'
    
    def _get_group_usage(self, group_name: str) -> str:
        """ã‚°ãƒ«ãƒ¼ãƒ—ã®ä¸»ãªç”¨é€”"""
        usages = {
            'core': '- ç‰©ä»¶ã®åŸºæœ¬è­˜åˆ¥ãƒ»ç®¡ç†\n- ä»–ãƒ†ãƒ¼ãƒ–ãƒ«ã¨ã®é–¢é€£ä»˜ã‘ã®åŸºç‚¹\n- ç‰©ä»¶ä¸€è¦§è¡¨ç¤ºã§ã®åŸºæœ¬æƒ…å ±æä¾›',
            'pricing': '- ç‰©ä»¶ä¾¡æ ¼ãƒ»è³ƒæ–™ã®ç®¡ç†\n- æŠ•è³‡åç›Šè¨ˆç®—ãƒ»åˆ©å›ã‚Šç®—å‡º\n- ä¾¡æ ¼å¸¯ã§ã®ç‰©ä»¶æ¤œç´¢ãƒ»çµã‚Šè¾¼ã¿',
            'location': '- ç‰©ä»¶æ‰€åœ¨åœ°ã®ç‰¹å®šãƒ»è¡¨ç¤º\n- åœ°åŸŸãƒ»é§…ã§ã®ç‰©ä»¶æ¤œç´¢\n- åœ°å›³è¡¨ç¤ºãƒ»ãƒ«ãƒ¼ãƒˆæ¡ˆå†…',
            'images': '- ç‰©ä»¶ç”»åƒã®ä¿å­˜ãƒ»ç®¡ç†\n- ç”»åƒã‚®ãƒ£ãƒ©ãƒªãƒ¼ã®è¡¨ç¤º\n- ç”»åƒã®åˆ†é¡ãƒ»æœ€é©åŒ–',
            'building': '- å»ºç‰©ä»•æ§˜ã®è©³ç´°è¡¨ç¤º\n- å»ºç¯‰æƒ…å ±ã«ã‚ˆã‚‹æ¤œç´¢ãƒ»çµã‚Šè¾¼ã¿\n- ç®¡ç†ãƒ»ãƒ¡ãƒ³ãƒ†ãƒŠãƒ³ã‚¹æƒ…å ±ã®ç®¡ç†',
            'contract': '- å¥‘ç´„æ¡ä»¶ã®ç®¡ç†ãƒ»è¡¨ç¤º\n- å…¥å±…æ™‚æœŸãƒ»å–å¼•æ¡ä»¶ã®ç¢ºèª\n- ä»²ä»‹æ‰‹æ•°æ–™ãƒ»å¥‘ç´„æœŸé–“ã®ç®¡ç†',
            'land': '- åœŸåœ°ã®æ³•çš„æƒ…å ±ç®¡ç†\n- ç”¨é€”åœ°åŸŸãƒ»æ¥é“ã«ã‚ˆã‚‹æ¤œç´¢\n- å»ºç¯‰å¯èƒ½æ€§ã®åˆ¤æ–­ææ–™',
            'facilities': '- å‘¨è¾ºç’°å¢ƒã®è©•ä¾¡ãƒ»è¡¨ç¤º\n- ç”Ÿæ´»åˆ©ä¾¿æ€§ã«ã‚ˆã‚‹ç‰©ä»¶è©•ä¾¡\n- ãƒ•ã‚¡ãƒŸãƒªãƒ¼å‘ã‘ç‰©ä»¶ã®è¨´æ±‚'
        }
        return usages.get(group_name, 'ç”¨é€”ã®è©³ç´°ã¯åˆ†æä¸­ã§ã™ã€‚')
    
    def _get_related_tables(self, group_name: str) -> str:
        """é–¢é€£ãƒ†ãƒ¼ãƒ–ãƒ«ã®èª¬æ˜"""
        relations = {
            'core': '- å…¨ã¦ã® properties_* ãƒ†ãƒ¼ãƒ–ãƒ«ã‹ã‚‰å‚ç…§ã•ã‚Œã‚‹ä¸­å¿ƒãƒ†ãƒ¼ãƒ–ãƒ«',
            'pricing': '- propertiesï¼ˆåŸºæœ¬æƒ…å ±ï¼‰\n- properties_buildingï¼ˆå»ºç‰©æƒ…å ±ã‹ã‚‰åˆ©å›ã‚Šè¨ˆç®—ï¼‰',
            'location': '- propertiesï¼ˆåŸºæœ¬æƒ…å ±ï¼‰\n- properties_transportationï¼ˆäº¤é€šæƒ…å ±ã¨é€£æºï¼‰',
            'images': '- propertiesï¼ˆåŸºæœ¬æƒ…å ±ï¼‰\n- image_typesï¼ˆç”»åƒç¨®åˆ¥ãƒã‚¹ã‚¿ãƒ¼ï¼‰',
            'building': '- propertiesï¼ˆåŸºæœ¬æƒ…å ±ï¼‰\n- building_structureï¼ˆå»ºç‰©æ§‹é€ ãƒã‚¹ã‚¿ãƒ¼ï¼‰',
            'contract': '- propertiesï¼ˆåŸºæœ¬æƒ…å ±ï¼‰\n- current_statusï¼ˆç¾æ³ãƒã‚¹ã‚¿ãƒ¼ï¼‰',
            'land': '- propertiesï¼ˆåŸºæœ¬æƒ…å ±ï¼‰\n- zoning_districtsï¼ˆç”¨é€”åœ°åŸŸãƒã‚¹ã‚¿ãƒ¼ï¼‰',
            'facilities': '- propertiesï¼ˆåŸºæœ¬æƒ…å ±ï¼‰'
        }
        return relations.get(group_name, 'é–¢é€£æ€§ã®è©³ç´°ã¯åˆ†æä¸­ã§ã™ã€‚')
    
    def _get_common_queries(self, group_name: str) -> str:
        """ã‚ˆãä½¿ã†ã‚¯ã‚¨ãƒªä¾‹"""
        queries = {
            'core': '''```sql
-- ç‰©ä»¶åŸºæœ¬æƒ…å ±å–å¾—
SELECT * FROM properties WHERE id = 12345;

-- ç‰©ä»¶ä¸€è¦§ï¼ˆãƒšãƒ¼ã‚¸ãƒ³ã‚°ï¼‰
SELECT id, building_property_name FROM properties 
ORDER BY id LIMIT 20 OFFSET 0;
```''',
            'pricing': '''```sql
-- ä¾¡æ ¼å¸¯ã§ã®æ¤œç´¢
SELECT p.*, pp.price FROM properties p
JOIN properties_pricing pp ON p.id = pp.property_id
WHERE pp.price BETWEEN 100000 AND 200000;

-- åˆ©å›ã‚Šé †ã§ã®ä¸¦ã³æ›¿ãˆ
SELECT * FROM properties_pricing 
ORDER BY yield DESC LIMIT 10;
```''',
            'location': '''```sql
-- ä½æ‰€ã§ã®æ¤œç´¢
SELECT * FROM properties_location 
WHERE address_name LIKE '%æ–°å®¿%';

-- ç·¯åº¦çµŒåº¦ã§ã®ç¯„å›²æ¤œç´¢
SELECT * FROM properties_location 
WHERE latitude_longitude IS NOT NULL;
```''',
            'images': '''```sql
-- ç‰©ä»¶ã®ç”»åƒä¸€è¦§
SELECT * FROM properties_images 
WHERE property_id = 12345 
ORDER BY image_order;

-- ç‰¹å®šç¨®åˆ¥ã®ç”»åƒ
SELECT * FROM properties_images 
WHERE image_type_1 = 'å¤–è¦³';
```'''
        }
        return queries.get(group_name, '```sql\n-- ä½¿ç”¨ä¾‹ã¯æº–å‚™ä¸­\n```')
    
    def _get_usage_examples_by_table(self, table_name: str, group_name: str) -> dict:
        """ãƒ†ãƒ¼ãƒ–ãƒ«åˆ¥ã®ä½¿ç”¨ä¾‹"""
        examples = {
            'properties': {
                'åŸºæœ¬æ¤œç´¢': f'SELECT * FROM {table_name} WHERE id = 12345;',
                'ä¸€è¦§å–å¾—': f'SELECT id, building_property_name FROM {table_name} ORDER BY id;'
            },
            'properties_pricing': {
                'ä¾¡æ ¼ç¯„å›²æ¤œç´¢': f'SELECT * FROM {table_name} WHERE price BETWEEN 100000 AND 200000;',
                'åˆ©å›ã‚Šä¸Šä½': f'SELECT * FROM {table_name} ORDER BY yield DESC LIMIT 10;'
            },
            'properties_images': {
                'ç‰©ä»¶ç”»åƒä¸€è¦§': f'SELECT * FROM {table_name} WHERE property_id = 12345;',
                'ç”»åƒç¨®åˆ¥çµã‚Šè¾¼ã¿': f'SELECT * FROM {table_name} WHERE image_type_1 = \'å¤–è¦³\';'
            }
        }
        
        return examples.get(table_name, {
            'åŸºæœ¬æ“ä½œ': f'SELECT * FROM {table_name} WHERE property_id = 12345;'
        })
    
    def _get_related_api_endpoints(self, table_name: str, group_name: str) -> list:
        """é–¢é€£APIã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆ"""
        endpoints = {
            'properties': [
                {'method': 'GET', 'path': '/api/v1/properties/', 'description': 'ç‰©ä»¶ä¸€è¦§å–å¾—'},
                {'method': 'POST', 'path': '/api/v1/properties/', 'description': 'ç‰©ä»¶ä½œæˆ'},
                {'method': 'GET', 'path': '/api/v1/properties/{id}', 'description': 'ç‰©ä»¶è©³ç´°å–å¾—'}
            ],
            'properties_pricing': [
                {'method': 'GET', 'path': '/api/v1/properties/{id}/pricing', 'description': 'ä¾¡æ ¼æƒ…å ±å–å¾—'},
                {'method': 'PUT', 'path': '/api/v1/properties/{id}/pricing', 'description': 'ä¾¡æ ¼æƒ…å ±æ›´æ–°'}
            ],
            'properties_images': [
                {'method': 'GET', 'path': '/api/v1/properties/{id}/images', 'description': 'ç”»åƒä¸€è¦§å–å¾—'},
                {'method': 'POST', 'path': '/api/v1/properties/{id}/images', 'description': 'ç”»åƒã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰'}
            ]
        }
        
        return endpoints.get(table_name, [])
    
    def _generate_tables_overview(self, inspector):
        """ãƒ†ãƒ¼ãƒ–ãƒ«ä¸€è¦§æ¦‚è¦ã®æ›´æ–°"""
        content = f"""# ğŸ“Š REAãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ ãƒ†ãƒ¼ãƒ–ãƒ«ä¸€è¦§

## ğŸ“‹ ç”Ÿæˆæƒ…å ±
- **ç”Ÿæˆæ—¥æ™‚**: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
- **ç·ãƒ†ãƒ¼ãƒ–ãƒ«æ•°**: {len(inspector.get_table_names())}
- **æ©Ÿèƒ½ã‚°ãƒ«ãƒ¼ãƒ—æ•°**: {len(self.table_groups)}

## ğŸ—‚ï¸ æ©Ÿèƒ½åˆ¥ãƒ†ãƒ¼ãƒ–ãƒ«æ§‹æˆ

"""
        
        for group_name, group_info in self.table_groups.items():
            content += f"### {group_info['icon']} {group_info['title']}\n"
            content += f"{group_info['description']}\n\n"
            
            for table_name in group_info['tables']:
                if table_name in inspector.get_table_names():
                    columns = inspector.get_columns(table_name)
                    record_count = self._get_record_count(table_name)
                    content += f"- [{table_name}]({group_name}/{table_name}.md) - {len(columns)}ã‚«ãƒ©ãƒ , {record_count:,}ãƒ¬ã‚³ãƒ¼ãƒ‰\n"
            
            content += "\n"
        
        # æ©Ÿèƒ½åˆ¥ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªä½œæˆ
        tables_dir = self.output_dir / "01_database" / "tables"
        tables_dir.mkdir(parents=True, exist_ok=True)
        
        with open(tables_dir / "README.md", 'w', encoding='utf-8') as f:
            f.write(content)
    
    def _print_summary(self):
        """ç”Ÿæˆçµæœã‚µãƒãƒªãƒ¼è¡¨ç¤º"""
        print("\nğŸ“‹ ãƒ†ãƒ¼ãƒ–ãƒ«è©³ç´°ä»•æ§˜ç”Ÿæˆçµæœ:")
        print("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€")
        
        total_files = 0
        for group_name, group_info in self.table_groups.items():
            group_dir = self.output_dir / "01_database" / "tables" / group_name
            if group_dir.exists():
                md_files = list(group_dir.glob("*.md"))
                total_files += len(md_files)
                print(f"{group_info['icon']} {group_info['title']}: {len(md_files)}ãƒ•ã‚¡ã‚¤ãƒ«")
        
        print(f"\nğŸ“„ ç·ç”Ÿæˆãƒ•ã‚¡ã‚¤ãƒ«æ•°: {total_files}")
        print("\nğŸ¯ æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—:")
        print("   1. docs/01_database/tables/ ã®å†…å®¹ç¢ºèª")
        print("   2. Day 2: Claudeç”¨ãƒãƒ£ãƒ³ã‚¯ç”Ÿæˆ")
        print("   3. Day 3: ãƒªãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ãƒ»ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹åˆ†æ")

if __name__ == "__main__":
    generator = TableDetailGenerator()
    generator.generate_all_table_details()

================================================================================
ğŸ“„ ãƒ•ã‚¡ã‚¤ãƒ«: scripts/auto_spec_generator/generators/database_generator.py
================================================================================
# generators/database_generator.py - æ”¹è¨‚ç‰ˆï¼ˆã‚·ãƒ³ãƒ—ãƒ«ãƒ»å®Ÿç”¨çš„ï¼‰
import sys
from pathlib import Path
from typing import Dict, Any
from .base_generator import BaseGenerator

class DatabaseGenerator(BaseGenerator):
    """ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ä»•æ§˜ç”Ÿæˆã‚¯ãƒ©ã‚¹"""
    
    def generate(self) -> Dict[str, Any]:
        """ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ä»•æ§˜ç”Ÿæˆ"""
        try:
            # Pythonãƒ‘ã‚¹ã«ãƒ™ãƒ¼ã‚¹ãƒ‘ã‚¹ã‚’è¿½åŠ 
            if str(self.base_path) not in sys.path:
                sys.path.insert(0, str(self.base_path))
            
            # å…±é€šãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’ä½¿ç”¨
            try:
                from shared.database import READatabase
                
                # DBæ¥ç¶šãƒ†ã‚¹ãƒˆ
                if not READatabase.test_connection():
                    return self._generate_fallback_spec("DBæ¥ç¶šå¤±æ•—")
                
                # DBå¥åº·ãƒã‚§ãƒƒã‚¯
                health = READatabase.health_check()
                
            except Exception as db_error:
                self.print_status(f"âš ï¸ DBæ¥ç¶šã‚¨ãƒ©ãƒ¼: {db_error}")
                return self._generate_fallback_spec(str(db_error))
            
            # ãƒ†ãƒ¼ãƒ–ãƒ«ä¸€è¦§å–å¾—
            tables = READatabase.get_all_tables()
            total_columns = 0
            
            content = f"""# REAãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ§‹é€ 

ç”Ÿæˆæ—¥æ™‚: {self.get_timestamp()}
ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹: {health['database']}
ãƒ†ãƒ¼ãƒ–ãƒ«æ•°: {len(tables)}

## ãƒ†ãƒ¼ãƒ–ãƒ«ä¸€è¦§

| ãƒ†ãƒ¼ãƒ–ãƒ«å | ã‚«ãƒ©ãƒ æ•° | ãƒ¬ã‚³ãƒ¼ãƒ‰æ•° | ç”¨é€” |
|------------|----------|------------|------|
"""
            
            # ãƒ†ãƒ¼ãƒ–ãƒ«æƒ…å ±ã‚’å–å¾—
            for table in sorted(tables):
                try:
                    table_info = READatabase.get_table_info(table)
                    column_count = table_info['column_count']
                    record_count = table_info['record_count']
                    total_columns += column_count
                    purpose = self._get_table_purpose(table)
                    content += f"| {table} | {column_count} | {record_count:,} | {purpose} |\n"
                except Exception as e:
                    content += f"| {table} | - | - | ã‚¨ãƒ©ãƒ¼ |\n"
            
            content += f"\nç·ã‚«ãƒ©ãƒ æ•°: {total_columns}\n"
            
            # å„ãƒ†ãƒ¼ãƒ–ãƒ«ã®è©³ç´°
            content += "\n## ãƒ†ãƒ¼ãƒ–ãƒ«è©³ç´°\n"
            
            for table in sorted(tables):
                try:
                    table_info = READatabase.get_table_info(table)
                    columns = table_info['columns']
                    
                    content += f"\n### {table}\n"
                    content += f"- ã‚«ãƒ©ãƒ æ•°: {table_info['column_count']}\n"
                    content += f"- ãƒ¬ã‚³ãƒ¼ãƒ‰æ•°: {table_info['record_count']:,}\n"
                    
                    if columns:
                        content += "\n| ã‚«ãƒ©ãƒ å | ãƒ‡ãƒ¼ã‚¿å‹ |\n"
                        content += "|----------|----------|\n"
                        for col in columns[:10]:  # æœ€åˆã®10ã‚«ãƒ©ãƒ ã®ã¿
                            content += f"| {col['column_name']} | {col['data_type']} |\n"
                        if len(columns) > 10:
                            content += f"\nä»– {len(columns)-10} ã‚«ãƒ©ãƒ \n"
                    
                except Exception:
                    content += f"\n### {table}\nå–å¾—ã‚¨ãƒ©ãƒ¼\n"
            
            # ãƒ•ã‚¡ã‚¤ãƒ«ä¿å­˜
            db_dir = self.get_output_dir("01_database")
            self.save_content(content, db_dir / "current_structure.md")
            
            self.print_status(f"âœ… ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ä»•æ§˜ç”Ÿæˆå®Œäº†: {len(tables)}ãƒ†ãƒ¼ãƒ–ãƒ«")
            return {
                "success": True,
                "tables": tables, 
                "total_columns": total_columns
            }
            
        except Exception as e:
            self.print_status(f"âŒ ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹åˆ†æã‚¨ãƒ©ãƒ¼: {e}")
            return self._generate_fallback_spec(str(e))
    
    def _generate_fallback_spec(self, error_message: str) -> Dict[str, Any]:
        """DBæ¥ç¶šå¤±æ•—æ™‚ã®ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ä»•æ§˜æ›¸ç”Ÿæˆ"""
        fallback_content = f"""# ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ¥ç¶šã‚¨ãƒ©ãƒ¼

ã‚¨ãƒ©ãƒ¼: {error_message}
ç™ºç”Ÿæ™‚åˆ»: {self.get_timestamp()}

## å¯¾å‡¦æ–¹æ³•

1. Docker PostgreSQLèµ·å‹•
   ```
   docker-compose up -d
   ```

2. æ¥ç¶šãƒ†ã‚¹ãƒˆ
   ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ«ãƒ¼ãƒˆã§å®Ÿè¡Œ:
   ```
   python -c "from shared.database import READatabase; print(READatabase.test_connection())"
   ```

3. ç’°å¢ƒå¤‰æ•°ç¢ºèª
   ```
   echo $DATABASE_URL
   ```
"""
        
        # ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ä»•æ§˜æ›¸ã‚’ä¿å­˜
        db_dir = self.get_output_dir("01_database")
        self.save_content(fallback_content, db_dir / "current_structure.md")
        
        return {
            "success": False, 
            "error": error_message
        }
    
    def _get_table_purpose(self, table_name: str) -> str:
        """ãƒ†ãƒ¼ãƒ–ãƒ«ç”¨é€”ã‚’æ¨å®š"""
        # æ—¢çŸ¥ã®ãƒ†ãƒ¼ãƒ–ãƒ«
        known_tables = {
            'properties': 'ç‰©ä»¶æƒ…å ±',
            'equipment_master': 'è¨­å‚™ãƒã‚¹ã‚¿ãƒ¼',
            'property_equipment': 'ç‰©ä»¶-è¨­å‚™é–¢é€£',
            'building_structure': 'å»ºç‰©æ§‹é€ ',
            'current_status': 'ç¾æ³',
            'property_types': 'ç‰©ä»¶ç¨®åˆ¥',
            'zoning_districts': 'ç”¨é€”åœ°åŸŸ',
            'land_rights': 'åœŸåœ°æ¨©åˆ©',
            'floor_plan_room_types': 'é–“å–ã‚Šã‚¿ã‚¤ãƒ—',
            'image_types': 'ç”»åƒç¨®åˆ¥',
            'column_labels': 'ã‚«ãƒ©ãƒ ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿'
        }
        
        if table_name in known_tables:
            return known_tables[table_name]
        
        # ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒãƒ³ã‚°
        if '_master' in table_name:
            return 'ãƒã‚¹ã‚¿ãƒ¼ãƒ‡ãƒ¼ã‚¿'
        elif 'properties_' in table_name:
            return 'ç‰©ä»¶é–¢é€£'
        elif '_log' in table_name:
            return 'ãƒ­ã‚°'
        
        return 'ä¸æ˜'

================================================================================
ğŸ“„ ãƒ•ã‚¡ã‚¤ãƒ«: rea-api/.env
================================================================================
# Database
DATABASE_URL=***MASKED***

# Redis
REDIS_URL=redis://localhost:6379

# Security
SECRET_KEY=your-secret-key-change-in-production
ALGORITHM=HS256
ACCESS_TOKEN_EXPIRE_MINUTES=30

# API
API_V1_STR=/api/v1
PROJECT_NAME=REA API

# File Upload
MAX_FILE_SIZE=10485760  # 10MB
UPLOAD_DIR=uploads


================================================================================
ğŸ“„ ãƒ•ã‚¡ã‚¤ãƒ«: rea-api/app/core/config.py
================================================================================
from pydantic_settings import BaseSettings
from typing import Optional

class Settings(BaseSettings):
    # APIè¨­å®š
    PROJECT_NAME: str = "REA API"
    API_V1_STR: str = "/api/v1"
    
    # ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£
    SECRET_KEY: str = "your-secret-key-change-in-production"
    ALGORITHM: str = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 30
    
    # ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹
    DATABASE_URL: str =***MASKED***
    
    # Redis
    REDIS_URL: str = "redis://localhost:6379"
    
    # ãƒ•ã‚¡ã‚¤ãƒ«ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰
    MAX_UPLOAD_SIZE: int = 10 * 1024 * 1024  # 10MB
    UPLOAD_DIR: str = "uploads"
    
    # CORS
    BACKEND_CORS_ORIGINS: list = [
        "http://localhost",
        "http://localhost:3000",
        "http://localhost:8000",
    ]
    
    # ãƒ­ã‚°è¨­å®š
    LOG_LEVEL: str = "INFO"
    
    class Config:
        env_file = ".env"
        case_sensitive = True

settings = Settings()

================================================================================
ğŸ“„ ãƒ•ã‚¡ã‚¤ãƒ«: rea-api/app/core/database.py
================================================================================
âŒ ãƒ•ã‚¡ã‚¤ãƒ«ãŒå­˜åœ¨ã—ã¾ã›ã‚“

================================================================================
ğŸ“„ ãƒ•ã‚¡ã‚¤ãƒ«: rea-scraper/.env
================================================================================
# Docker PostgreSQLè¨­å®š
DATABASE_URL=***MASKED***
DB_HOST=localhost
DB_PORT=5432
DB_NAME=real_estate_db
DB_USER=rea_user
DB_PASSWORD=***MASKED***

# ã‚¹ã‚¯ãƒ¬ã‚¤ãƒ”ãƒ³ã‚°è¨­å®š
HEADLESS=true
TEST_MODE=false
LOG_LEVEL=INFO

# ä¿å­˜è¨­å®š
SAVE_TO_DB=true
SAVE_TO_FILE=false

================================================================================
ğŸ“„ ãƒ•ã‚¡ã‚¤ãƒ«: rea-scraper/src/config/settings.py
================================================================================
"""
REA Scraper è¨­å®šç®¡ç†
æ±ç”¨å­¦ç¿’ã‚¹ã‚¯ãƒ¬ã‚¤ãƒ”ãƒ³ã‚°ã‚·ã‚¹ãƒ†ãƒ ã®è¨­å®šã‚’ä¸€å…ƒç®¡ç†
"""
import os
from pathlib import Path
from typing import Any, Dict, Optional

from dotenv import load_dotenv
from loguru import logger

# .envãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã¿
load_dotenv()

# ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®ãƒ«ãƒ¼ãƒˆãƒ‘ã‚¹
BASE_DIR = Path(__file__).resolve().parent.parent.parent
SRC_DIR = BASE_DIR / "src"
DATA_DIR = BASE_DIR / "data"
LOGS_DIR = BASE_DIR / "logs"
MODELS_DIR = BASE_DIR / "models"
DOWNLOADS_DIR = BASE_DIR / "downloads"

# ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªãŒå­˜åœ¨ã—ãªã„å ´åˆã¯ä½œæˆ
for dir_path in [DATA_DIR, LOGS_DIR, MODELS_DIR, DOWNLOADS_DIR]:
    dir_path.mkdir(exist_ok=True)


class Settings:
    """è¨­å®šã‚¯ãƒ©ã‚¹"""

    # =========== ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹è¨­å®š ===========
    DATABASE_URL: str = os.getenv(
        "DATABASE_URL",
        "postgresql://postgres:postgres@localhost:5432/real_estate_db",  # â† ã“ã“ã ã‘å¤‰æ›´
    )

    # =========== Redisè¨­å®š ===========
    REDIS_URL: str = os.getenv("REDIS_URL", "redis://localhost:6379/0")
    REDIS_CACHE_TTL: int = 3600  # ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã®æœ‰åŠ¹æœŸé™ï¼ˆç§’ï¼‰

    # =========== Seleniumè¨­å®š ===========
    CHROME_DRIVER_PATH: Optional[str] = os.getenv("CHROME_DRIVER_PATH")
    HEADLESS_MODE: bool = os.getenv("HEADLESS_MODE", "False").lower() == "true"
    WINDOW_SIZE: tuple = (1920, 1080)
    USER_AGENT: str = (
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) "
        "AppleWebKit/537.36 (KHTML, like Gecko) "
        "Chrome/120.0.0.0 Safari/537.36"
    )

    # =========== ã‚¹ã‚¯ãƒ¬ã‚¤ãƒ”ãƒ³ã‚°è¨­å®š ===========
    DEFAULT_TIMEOUT: int = int(os.getenv("DEFAULT_TIMEOUT", "30"))
    RETRY_COUNT: int = int(os.getenv("RETRY_COUNT", "3"))
    RETRY_DELAY: int = 5  # ãƒªãƒˆãƒ©ã‚¤é–“éš”ï¼ˆç§’ï¼‰
    RATE_LIMIT_DELAY: float = float(os.getenv("RATE_LIMIT_DELAY", "2"))
    MAX_CONCURRENT_REQUESTS: int = 3  # åŒæ™‚ãƒªã‚¯ã‚¨ã‚¹ãƒˆæ•°

    # =========== ãƒ­ã‚°è¨­å®š ===========
    LOG_LEVEL: str = os.getenv("LOG_LEVEL", "INFO")
    LOG_FILE: str = os.getenv("LOG_FILE", str(LOGS_DIR / "rea_scraper.log"))
    LOG_ROTATION: str = "10 MB"  # ãƒ­ã‚°ãƒ­ãƒ¼ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³
    LOG_RETENTION: str = "30 days"  # ãƒ­ã‚°ä¿æŒæœŸé–“
    LOG_FORMAT: str = (
        "<green>{time:YYYY-MM-DD HH:mm:ss.SSS}</green> | "
        "<level>{level: <8}</level> | "
        "<cyan>{name}</cyan>:<cyan>{function}</cyan>:<cyan>{line}</cyan> | "
        "<level>{message}</level>"
    )

    # =========== APIè¨­å®š ===========
    REA_API_URL: str = os.getenv("REA_API_URL", "http://localhost:8005")
    API_TIMEOUT: int = 30
    API_KEY: Optional[str] = os.getenv("API_KEY")

    # =========== æ±ç”¨å­¦ç¿’è¨­å®š ===========
    # å­¦ç¿’ãƒ¢ãƒ¼ãƒ‰
    LEARNING_MODE: bool = True
    MIN_CONFIDENCE_THRESHOLD: float = 0.7  # æœ€å°ä¿¡é ¼åº¦é–¾å€¤

    # ãƒ‘ã‚¿ãƒ¼ãƒ³å­¦ç¿’è¨­å®š
    PATTERN_MIN_SAMPLES: int = 10  # ãƒ‘ã‚¿ãƒ¼ãƒ³å­¦ç¿’ã«å¿…è¦ãªæœ€å°ã‚µãƒ³ãƒ—ãƒ«æ•°
    PATTERN_SIMILARITY_THRESHOLD: float = 0.8  # ãƒ‘ã‚¿ãƒ¼ãƒ³é¡ä¼¼åº¦é–¾å€¤

    # å“è³ªè©•ä¾¡è¨­å®š
    QUALITY_CHECK_ENABLED: bool = True
    QUALITY_MIN_SCORE: float = 0.6  # æœ€å°å“è³ªã‚¹ã‚³ã‚¢

    # ãƒ¢ãƒ‡ãƒ«ä¿å­˜è¨­å®š
    MODEL_SAVE_INTERVAL: int = 100  # ãƒ¢ãƒ‡ãƒ«ä¿å­˜é–“éš”ï¼ˆå‡¦ç†ä»¶æ•°ï¼‰
    MODEL_VERSION_CONTROL: bool = True  # ãƒ¢ãƒ‡ãƒ«ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ç®¡ç†

    # =========== ã‚µã‚¤ãƒˆåˆ¥è¨­å®š ===========
    SITE_CONFIGS: Dict[str, Dict[str, Any]] = {
        "homes": {
            "base_url": "https://www.homes.co.jp",
            "rate_limit": 2.0,  # ç§’
            "timeout": 30,
            "retry_count": 3,
            "priority": 1,  # å­¦ç¿’å„ªå…ˆåº¦
        },
        "suumo": {
            "base_url": "https://suumo.jp",
            "rate_limit": 2.5,
            "timeout": 30,
            "retry_count": 3,
            "priority": 2,
        },
        "athome": {
            "base_url": "https://www.athome.co.jp",
            "rate_limit": 3.0,
            "timeout": 30,
            "retry_count": 3,
            "priority": 3,
        },
    }

    # =========== ç”»åƒå‡¦ç†è¨­å®š ===========
    IMAGE_DOWNLOAD_ENABLED: bool = True
    IMAGE_MAX_SIZE: tuple = (1920, 1080)  # æœ€å¤§ç”»åƒã‚µã‚¤ã‚º
    IMAGE_QUALITY: int = 85  # JPEGå“è³ª
    IMAGE_FORMAT: str = "JPEG"

    # =========== ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ©ãƒ¼è¨­å®š ===========
    SCHEDULER_ENABLED: bool = False
    SCHEDULER_TIMEZONE: str = "Asia/Tokyo"
    SCHEDULER_JOBS: list = [
        {
            "id": "daily_scraping",
            "func": "src.scheduler:daily_scraping_job",
            "trigger": "cron",
            "hour": 2,
            "minute": 0,
        },
    ]

    # =========== ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£è¨­å®š ===========
    PROXY_ENABLED: bool = False
    PROXY_LIST: list = []
    ROTATE_USER_AGENT: bool = True
    USER_AGENT_LIST: list = [
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36",
        "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36",
        "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36",
    ]

    # =========== é–‹ç™º/æœ¬ç•ªç’°å¢ƒè¨­å®š ===========
    ENVIRONMENT: str = os.getenv("ENVIRONMENT", "development")
    DEBUG: bool = ENVIRONMENT == "development"

    @classmethod
    def get_site_config(cls, site_name: str) -> Dict[str, Any]:
        """ã‚µã‚¤ãƒˆåˆ¥è¨­å®šã‚’å–å¾—"""
        return cls.SITE_CONFIGS.get(site_name, {})

    @classmethod
    def validate(cls) -> None:
        """è¨­å®šã®å¦¥å½“æ€§ã‚’ãƒã‚§ãƒƒã‚¯"""
        # å¿…é ˆãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã®å­˜åœ¨ç¢ºèª
        required_dirs = [DATA_DIR, LOGS_DIR, MODELS_DIR]
        for dir_path in required_dirs:
            if not dir_path.exists():
                raise ValueError(f"Required directory not found: {dir_path}")

        # ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ¥ç¶šæ–‡å­—åˆ—ã®ç¢ºèª
        if not cls.DATABASE_URL:
            raise ValueError("DATABASE_URL is not set")

        # API URLã®ç¢ºèª
        if not cls.REA_API_URL:
            raise ValueError("REA_API_URL is not set")

        logger.info("Settings validation completed successfully")


# è¨­å®šã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹
settings = Settings()

# ãƒ­ã‚°è¨­å®šã®åˆæœŸåŒ–
logger.add(
    settings.LOG_FILE,
    rotation=settings.LOG_ROTATION,
    retention=settings.LOG_RETENTION,
    level=settings.LOG_LEVEL,
    format=settings.LOG_FORMAT,
    backtrace=True,
    diagnose=True,
)

# è¨­å®šã®æ¤œè¨¼ï¼ˆé–‹ç™ºç’°å¢ƒã®ã¿ï¼‰
if settings.DEBUG:
    try:
        settings.validate()
    except ValueError as e:
        logger.error(f"Settings validation failed: {e}")
        raise


================================================================================
ğŸ“„ ãƒ•ã‚¡ã‚¤ãƒ«: rea-scraper/src/config/database.py
================================================================================
âŒ ãƒ•ã‚¡ã‚¤ãƒ«ãŒå­˜åœ¨ã—ã¾ã›ã‚“

================================================================================
ğŸ“„ ãƒ•ã‚¡ã‚¤ãƒ«: shared/database.py
================================================================================
"""REA ã‚·ãƒ³ãƒ—ãƒ«ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ¥ç¶š

ã€é‡è¦ã€‘DBæ¥ç¶šè¨­å®šã«ã¤ã„ã¦
========================
ã“ã®ãƒ•ã‚¡ã‚¤ãƒ«ã¯å¿…ãšãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ«ãƒ¼ãƒˆã®.envãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰è¨­å®šã‚’èª­ã¿è¾¼ã¿ã¾ã™ã€‚
.envãƒ•ã‚¡ã‚¤ãƒ«ã®å ´æ‰€: /Users/yaguchimakoto/my_programing/REA/.env

.envãƒ•ã‚¡ã‚¤ãƒ«ã«ä»¥ä¸‹ã®è¨­å®šãŒå¿…è¦ã§ã™ï¼š

DB_HOST=localhost        # Docker PostgreSQLæ¥ç¶šç”¨
DB_PORT=5432            # PostgreSQLã®ãƒãƒ¼ãƒˆ
DB_NAME=real_estate_db  # ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹å
DB_USER=rea_user        # ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ãƒ¦ãƒ¼ã‚¶ãƒ¼å
DB_PASSWORD=***MASKED***

ã€å…±é€šãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®ä»•æ§˜ã€‘
========================
- ã©ã“ã‹ã‚‰å®Ÿè¡Œã—ã¦ã‚‚åŒã˜.envãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä½¿ç”¨
- è¨­å®šã®ä¸€å…ƒç®¡ç†ã‚’å®Ÿç¾
- å®Ÿè¡Œå ´æ‰€ã«ä¾å­˜ã—ãªã„å®‰å®šã—ãŸæ¥ç¶š
- å…¨ã¦ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ã“ã®ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’çµŒç”±ã—ã¦DBæ¥ç¶šã™ã‚‹

ã€å¤‰æ›´å±¥æ­´ã€‘
========================
2025-07-23: ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ«ãƒ¼ãƒˆå›ºå®šåŒ–ï¼ˆæŠ€è¡“çš„è² å‚µè§£æ¶ˆï¼‰
           - å®Ÿè¡Œå ´æ‰€ã«ã‚ˆã‚‹.envèª­ã¿è¾¼ã¿ã®å·®ç•°ã‚’è§£æ¶ˆ
           - DBæ¥ç¶šã®å®Œå…¨çµ±ä¸€åŒ–ã‚’å®Ÿç¾
"""

import os
import psycopg2
from psycopg2.extras import RealDictCursor
from typing import List, Dict, Any, Optional
from pathlib import Path

class READatabase:
    """ã‚·ãƒ³ãƒ—ãƒ«ãªDBæ¥ç¶šã‚¯ãƒ©ã‚¹
    
    REAãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®å…¨ã¦ã®DBæ¥ç¶šã‚’çµ±ä¸€ç®¡ç†ã™ã‚‹å…±é€šãƒ©ã‚¤ãƒ–ãƒ©ãƒªã€‚
    ã©ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‹ã‚‰ä½¿ç”¨ã—ã¦ã‚‚åŒã˜è¨­å®šã§æ¥ç¶šã§ãã‚‹ã“ã¨ã‚’ä¿è¨¼ã™ã‚‹ã€‚
    """
    
    @classmethod
    def _load_env(cls):
        """ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ«ãƒ¼ãƒˆã®.envãƒ•ã‚¡ã‚¤ãƒ«ã‚’å¿…ãšèª­ã¿è¾¼ã‚€
        
        å…±é€šãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®æ ¸å¿ƒéƒ¨åˆ†ï¼š
        - å¸¸ã«ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ«ãƒ¼ãƒˆã®.envã‚’ä½¿ç”¨
        - ã©ã“ã‹ã‚‰å®Ÿè¡Œã—ã¦ã‚‚åŒã˜è¨­å®šã‚’ä½¿ç”¨
        - è¨­å®šã®ä¸€å…ƒç®¡ç†ã‚’å®Ÿç¾
        
        å¤‰æ›´å‰ã®å•é¡Œç‚¹ï¼š
        - ã‚«ãƒ¬ãƒ³ãƒˆãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‹ã‚‰æ¢ã—ã¦ã„ãŸãŸã‚ã€å®Ÿè¡Œå ´æ‰€ã«ã‚ˆã‚Šç•°ãªã‚‹.envã‚’èª­ã‚“ã§ã„ãŸ
        - auto_spec_generatorã‹ã‚‰å®Ÿè¡Œæ™‚ã¨REAãƒ«ãƒ¼ãƒˆã‹ã‚‰å®Ÿè¡Œæ™‚ã§æŒ™å‹•ãŒç•°ãªã£ã¦ã„ãŸ
        
        è§£æ±ºç­–ï¼š
        - ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ«ãƒ¼ãƒˆã‚’å›ºå®šãƒ‘ã‚¹ã§æŒ‡å®š
        - ã©ã“ã‹ã‚‰å®Ÿè¡Œã—ã¦ã‚‚å¿…ãšåŒã˜.envãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã‚€
        """
        # ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ«ãƒ¼ãƒˆã‚’å›ºå®šï¼ˆã©ã“ã‹ã‚‰å®Ÿè¡Œã—ã¦ã‚‚åŒã˜ï¼‰
        project_root = Path('/Users/yaguchimakoto/my_programing/REA')
        env_path = project_root / '.env'
        
        if env_path.exists():
            with open(env_path) as f:
                for line in f:
                    if '=' in line and not line.startswith('#'):
                        key, value = line.strip().split('=', 1)
                        os.environ[key] = value.strip('"\'')
        else:
            print(f"è­¦å‘Š: .envãƒ•ã‚¡ã‚¤ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: {env_path}")
            print("ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚")
    
    @classmethod
    def get_connection(cls):
        """DBæ¥ç¶šã‚’å–å¾—
        
        ç’°å¢ƒå¤‰æ•°ã‹ã‚‰æ¥ç¶šæƒ…å ±ã‚’å–å¾—ã—ã¾ã™ã€‚
        å¿…ãšãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ«ãƒ¼ãƒˆã®.envãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã¿ã¾ã™ã€‚
        
        ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ï¼š
        - host: localhost
        - port: 5432
        - database: real_estate_db
        - user: rea_user
        - password: ***MASKED***
        
        Returns:
            psycopg2.connection: PostgreSQLæ¥ç¶šã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
            
        Raises:
            psycopg2.OperationalError: æ¥ç¶šå¤±æ•—æ™‚
        """
        cls._load_env()
        
        # æ¥ç¶šæƒ…å ±ï¼ˆ.envã‹ã‚‰èª­ã¿è¾¼ã¿ã€ãªã‘ã‚Œã°ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ï¼‰
        return psycopg2.connect(
            host=os.getenv('DB_HOST', 'localhost'),
            port=os.getenv('DB_PORT', '5432'),
            database=os.getenv('DB_NAME', 'real_estate_db'),
            user=os.getenv('DB_USER', 'rea_user'),
            password=***MASKED***
        )
    
    @classmethod
    def test_connection(cls) -> bool:
        """æ¥ç¶šãƒ†ã‚¹ãƒˆ
        
        DBæ¥ç¶šãŒå¯èƒ½ã‹ãƒ†ã‚¹ãƒˆã—ã¾ã™ã€‚
        å…¨ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§ä½¿ç”¨å‰ã«ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã§ãƒ†ã‚¹ãƒˆã™ã‚‹ã“ã¨ã‚’æ¨å¥¨ã€‚
        
        Returns:
            bool: æ¥ç¶šæˆåŠŸæ™‚Trueã€å¤±æ•—æ™‚False
            
        Example:
            if READatabase.test_connection():
                print("DBæ¥ç¶šæˆåŠŸï¼")
            else:
                print("DBæ¥ç¶šå¤±æ•—ï¼.envãƒ•ã‚¡ã‚¤ãƒ«ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚")
        """
        try:
            conn = cls.get_connection()
            conn.close()
            return True
        except Exception as e:
            print(f"DBæ¥ç¶šã‚¨ãƒ©ãƒ¼: {e}")
            return False
    
    @classmethod
    def execute_query(cls, query: str, params: Optional[tuple] = None) -> List[tuple]:
        """ã‚¯ã‚¨ãƒªå®Ÿè¡Œï¼ˆã‚¿ãƒ—ãƒ«å½¢å¼ï¼‰
        
        åŸºæœ¬çš„ãªSQLå®Ÿè¡Œãƒ¡ã‚½ãƒƒãƒ‰ã€‚çµæœã¯ã‚¿ãƒ—ãƒ«ã®ãƒªã‚¹ãƒˆã§è¿”ã™ã€‚
        
        Args:
            query: SQLæ–‡ï¼ˆãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã¯%sã§ãƒ—ãƒ¬ãƒ¼ã‚¹ãƒ›ãƒ«ãƒ€ï¼‰
            params: ãƒã‚¤ãƒ³ãƒ‰ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ï¼ˆSQLã‚¤ãƒ³ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³å¯¾ç­–ï¼‰
            
        Returns:
            List[tuple]: å®Ÿè¡Œçµæœ
            
        Example:
            result = READatabase.execute_query(
                "SELECT id, title FROM properties WHERE price > %s",
                (10000000,)
            )
            for row in result:
                print(f"ID: {row[0]}, Title: {row[1]}")
        """
        conn = cls.get_connection()
        cur = conn.cursor()
        cur.execute(query, params or ())
        result = cur.fetchall() if cur.description else []
        conn.close()
        return result
    
    @classmethod
    def execute_query_dict(cls, query: str, params: Optional[tuple] = None) -> List[Dict[str, Any]]:
        """ã‚¯ã‚¨ãƒªå®Ÿè¡Œï¼ˆè¾æ›¸å½¢å¼ï¼‰
        
        çµæœã‚’è¾æ›¸å½¢å¼ã§è¿”ã™ãŸã‚ã€ã‚«ãƒ©ãƒ åã§ã‚¢ã‚¯ã‚»ã‚¹å¯èƒ½ã€‚
        å®Ÿç”¨çš„ãªãƒ‡ãƒ¼ã‚¿å‡¦ç†ã«æœ€é©ã€‚
        
        Args:
            query: SQLæ–‡
            params: ãƒã‚¤ãƒ³ãƒ‰ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
            
        Returns:
            List[Dict[str, Any]]: å®Ÿè¡Œçµæœï¼ˆã‚«ãƒ©ãƒ åã‚’ã‚­ãƒ¼ã¨ã™ã‚‹è¾æ›¸ã®ãƒªã‚¹ãƒˆï¼‰
            
        Example:
            properties = READatabase.execute_query_dict(
                "SELECT * FROM properties WHERE price > %s LIMIT 5",
                (10000000,)
            )
            for prop in properties:
                print(f"{prop['title']}: {prop['price']}å††")
        """
        conn = cls.get_connection()
        cur = conn.cursor(cursor_factory=RealDictCursor)
        cur.execute(query, params or ())
        result = cur.fetchall() if cur.description else []
        conn.close()
        return [dict(row) for row in result]
    
    @classmethod
    def get_all_tables(cls) -> List[str]:
        """ãƒ†ãƒ¼ãƒ–ãƒ«ä¸€è¦§å–å¾—
        
        publicã‚¹ã‚­ãƒ¼ãƒã®å…¨ãƒ†ãƒ¼ãƒ–ãƒ«ã‚’å–å¾—ã€‚
        DBæ§‹é€ ã®ç¢ºèªã‚„ä»•æ§˜æ›¸ç”Ÿæˆã§ä½¿ç”¨ã€‚
        
        Returns:
            List[str]: publicã‚¹ã‚­ãƒ¼ãƒã®ãƒ†ãƒ¼ãƒ–ãƒ«åä¸€è¦§
            
        Example:
            tables = READatabase.get_all_tables()
            print(f"ãƒ†ãƒ¼ãƒ–ãƒ«æ•°: {len(tables)}")
            for table in tables:
                print(f"- {table}")
        """
        query = """
        SELECT table_name 
        FROM information_schema.tables 
        WHERE table_schema = 'public' 
        ORDER BY table_name
        """
        result = cls.execute_query(query)
        return [row[0] for row in result]
    
    @classmethod
    def get_table_info(cls, table_name: str) -> Dict[str, Any]:
        """ãƒ†ãƒ¼ãƒ–ãƒ«æƒ…å ±å–å¾—
        
        æŒ‡å®šãƒ†ãƒ¼ãƒ–ãƒ«ã®è©³ç´°æƒ…å ±ã‚’å–å¾—ã€‚
        ã‚«ãƒ©ãƒ æƒ…å ±ã€ãƒ¬ã‚³ãƒ¼ãƒ‰æ•°ãªã©ã‚’å«ã‚€ã€‚
        
        Args:
            table_name: ãƒ†ãƒ¼ãƒ–ãƒ«å
            
        Returns:
            Dict[str, Any]: ãƒ†ãƒ¼ãƒ–ãƒ«æƒ…å ±
                - table_name: ãƒ†ãƒ¼ãƒ–ãƒ«å
                - columns: ã‚«ãƒ©ãƒ æƒ…å ±ã®ãƒªã‚¹ãƒˆ
                - column_count: ã‚«ãƒ©ãƒ æ•°
                - record_count: ãƒ¬ã‚³ãƒ¼ãƒ‰æ•°
                
        Example:
            info = READatabase.get_table_info('properties')
            print(f"ã‚«ãƒ©ãƒ æ•°: {info['column_count']}")
            print(f"ãƒ¬ã‚³ãƒ¼ãƒ‰æ•°: {info['record_count']}")
        """
        query = """
        SELECT 
            column_name,
            data_type,
            is_nullable,
            column_default
        FROM information_schema.columns 
        WHERE table_name = %s
        ORDER BY ordinal_position
        """
        columns = cls.execute_query_dict(query, (table_name,))
        
        # ãƒ¬ã‚³ãƒ¼ãƒ‰æ•°å–å¾—ï¼ˆå®‰å…¨ãªãƒ†ãƒ¼ãƒ–ãƒ«åãƒã‚§ãƒƒã‚¯ï¼‰
        if not table_name.replace('_', '').isalnum():
            raise ValueError(f"ä¸æ­£ãªãƒ†ãƒ¼ãƒ–ãƒ«å: {table_name}")
            
        count_result = cls.execute_query(f"SELECT COUNT(*) FROM {table_name}")
        record_count = count_result[0][0] if count_result else 0
        
        return {
            'table_name': table_name,
            'columns': columns,
            'column_count': len(columns),
            'record_count': record_count
        }
    
    @classmethod
    def health_check(cls) -> Dict[str, Any]:
        """DBå¥åº·ãƒã‚§ãƒƒã‚¯
        
        DBæ¥ç¶šã®è©³ç´°ãªçŠ¶æ…‹ã‚’ç¢ºèªã€‚
        ãƒ¢ãƒ‹ã‚¿ãƒªãƒ³ã‚°ã‚„ãƒ‡ãƒãƒƒã‚°ã§ä½¿ç”¨ã€‚
        
        Returns:
            Dict[str, Any]: DBæ¥ç¶šçŠ¶æ…‹
                - status: 'healthy' or 'unhealthy'
                - database: ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹å
                - version: PostgreSQLãƒãƒ¼ã‚¸ãƒ§ãƒ³
                - config_source: è¨­å®šã‚½ãƒ¼ã‚¹
                - error: ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ï¼ˆã‚¨ãƒ©ãƒ¼æ™‚ã®ã¿ï¼‰
                
        Example:
            health = READatabase.health_check()
            if health['status'] == 'healthy':
                print(f"DBæ­£å¸¸: {health['database']}")
                print(f"ãƒãƒ¼ã‚¸ãƒ§ãƒ³: {health['version']}")
            else:
                print(f"DBã‚¨ãƒ©ãƒ¼: {health['error']}")
        """
        try:
            conn = cls.get_connection()
            cur = conn.cursor()
            
            # PostgreSQLãƒãƒ¼ã‚¸ãƒ§ãƒ³å–å¾—
            cur.execute("SELECT version()")
            version = cur.fetchone()[0]
            
            # ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹åå–å¾—
            cur.execute("SELECT current_database()")
            database = cur.fetchone()[0]
            
            conn.close()
            
            return {
                'status': 'healthy',
                'database': database,
                'version': version,
                'config_source': 'ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ«ãƒ¼ãƒˆ/.env',
                'response_time_ms': 10  # ç°¡æ˜“çš„ãªå€¤
            }
        except Exception as e:
            return {
                'status': 'unhealthy',
                'error': str(e),
                'database': 'unknown',
                'version': 'unknown',
                'config_source': 'unknown',
                'response_time_ms': 0
            }

# ç°¡å˜ã«ä½¿ãˆã‚‹é–¢æ•°ï¼ˆå¾Œæ–¹äº’æ›æ€§ã®ãŸã‚ç¶­æŒï¼‰
def quick_test():
    """æ¥ç¶šãƒ†ã‚¹ãƒˆã®ã‚·ãƒ§ãƒ¼ãƒˆã‚«ãƒƒãƒˆ
    
    æ—¢å­˜ã‚³ãƒ¼ãƒ‰ã¨ã®äº’æ›æ€§ã®ãŸã‚ç¶­æŒã€‚
    æ–°è¦ã‚³ãƒ¼ãƒ‰ã§ã¯READatabase.test_connection()ã‚’æ¨å¥¨ã€‚
    """
    return READatabase.test_connection()

def get_tables():
    """ãƒ†ãƒ¼ãƒ–ãƒ«ä¸€è¦§å–å¾—ã®ã‚·ãƒ§ãƒ¼ãƒˆã‚«ãƒƒãƒˆ
    
    æ—¢å­˜ã‚³ãƒ¼ãƒ‰ã¨ã®äº’æ›æ€§ã®ãŸã‚ç¶­æŒã€‚
    æ–°è¦ã‚³ãƒ¼ãƒ‰ã§ã¯READatabase.get_all_tables()ã‚’æ¨å¥¨ã€‚
    """
    return READatabase.get_all_tables()


# ===== ä½¿ç”¨ä¾‹ =====
# 
# ã€åŸºæœ¬çš„ãªä½¿ã„æ–¹ã€‘
# 
# # 1. æ¥ç¶šãƒ†ã‚¹ãƒˆ
# if READatabase.test_connection():
#     print("DBæ¥ç¶šæˆåŠŸï¼")
# else:
#     print("DBæ¥ç¶šå¤±æ•—ï¼")
# 
# # 2. ãƒ†ãƒ¼ãƒ–ãƒ«ä¸€è¦§å–å¾—
# tables = READatabase.get_all_tables()
# print(f"ãƒ†ãƒ¼ãƒ–ãƒ«æ•°: {len(tables)}")
# 
# # 3. ãƒ‡ãƒ¼ã‚¿å–å¾—ï¼ˆè¾æ›¸å½¢å¼ï¼‰
# properties = READatabase.execute_query_dict(
#     "SELECT * FROM properties WHERE price > %s LIMIT 5",
#     (10000000,)
# )
# for prop in properties:
#     print(f"{prop['title']}: {prop['price']}å††")
# 
# # 4. ãƒ†ãƒ¼ãƒ–ãƒ«æƒ…å ±å–å¾—
# info = READatabase.get_table_info('properties')
# print(f"propertiesãƒ†ãƒ¼ãƒ–ãƒ«: {info['column_count']}ã‚«ãƒ©ãƒ , {info['record_count']}ä»¶")
# 
# # 5. DBå¥åº·ãƒã‚§ãƒƒã‚¯
# health = READatabase.health_check()
# print(f"DBçŠ¶æ…‹: {health['status']}")
# 
# ã€ä»–ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‹ã‚‰ã®ä½¿ã„æ–¹ã€‘
# 
# # rea-api ã‹ã‚‰ä½¿ã†å ´åˆ
# from shared.database import READatabase
# 
# # rea-scraper ã‹ã‚‰ä½¿ã†å ´åˆ
# import sys
# sys.path.append('/Users/yaguchimakoto/my_programing/REA')
# from shared.database import READatabase
# 
# # ã©ã“ã‹ã‚‰ä½¿ã£ã¦ã‚‚åŒã˜.envãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã‚€ã®ã§å®‰å¿ƒï¼

================================================================================
ãƒ€ãƒ³ãƒ—å®Œäº†
================================================================================
